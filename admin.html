<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>管理ダッシュボード — Kiroku Lot</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,'Hiragino Kaku Gothic ProN','Noto Sans JP',sans-serif;margin:24px}
    .card{border:1px solid #ddd;border-radius:8px;padding:16px;margin:12px 0}
    textarea{width:100%;height:220px;font-family:monospace;white-space:pre;}
    input[type=password]{font-size:16px;padding:8px;width:260px}
    button{padding:8px 12px;margin:6px}
    table{border-collapse:collapse;width:100%}
    th,td{border:1px solid #eee;padding:6px;text-align:left}
    .muted{color:#666;font-size:14px}
    .hidden{display:none}
    .danger{color:#a00}
  </style>
</head>
<body>
  <h1>管理者ダッシュボード</h1>
  <div class="card" id="loginCard">
    <p>パスワードを入力してログインしてください。</p>
    <input id="pw" type="password" placeholder="パスワードを入力">
    <button id="loginBtn">ログイン</button>
    <p class="muted">※ フロントエンドのみの保護です。本番運用ではサーバー側認証を必ず実装してください。</p>
  </div>

  <div id="dashboard" class="hidden">
    <div style="display:flex;gap:12px;align-items:center">
      <h2>データ集計</h2>
      <button id="refreshBtn">再取得</button>
      <button id="downloadBtn">JSON をダウンロード</button>
      <button id="logoutBtn">ログアウト</button>
    </div>

    <div class="card">
      <h3>概要</h3>
      <div id="summary"></div>
    </div>

    <div class="card">
      <h3>ユーザー別集計</h3>
      <div id="usersAggregate"></div>
    </div>

    <div class="card">
      <h3>Ping（サイト健診）</h3>
      <p class="muted">10秒ごとにサイトへリクエストを送り、応答時間と成功率を記録します。サーバーの CPU/メモリ は取得できないため、ここでは応答レイテンシを監視します。</p>
      <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
        <button id="pingManual">今すぐ ping</button>
        <button id="togglePing">停止</button>
        <span id="pingStatus" class="muted"></span>
      </div>
      <canvas id="pingChart" width="700" height="120" style="width:100%;height:80px;border:1px solid #eee;border-radius:6px;"></canvas>
      <div id="pingStats" style="margin-top:8px"></div>
    </div>

    <div class="card">
      <h3>クライアント（ブラウザ）情報</h3>
      <div id="clientStats"></div>
      <p class="muted">※ サーバー側の CPU / メモリ 情報は取得できません。Netlify 等のホスティング環境でサーバー側メトリクスを得たい場合は外部モニタリング（Datadog, Prometheus 等）かビルド時のログ収集を検討してください。</p>
    </div>

    <div class="card">
      <h3>アクセスログ / アクセス数</h3>
      <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
        <button id="refreshAccess">再取得</button>
        <button id="clearAccess">クリア</button>
        <button id="downloadAccess">CSV ダウンロード</button>
        <button id="fetchServerLogs">サーバーログ取得</button>
        <span id="accessSummary" class="muted"></span>
      </div>
      <div id="accessCounts"></div>
      <div style="margin-top:8px;max-height:240px;overflow:auto;border-top:1px dashed #eee;padding-top:8px">
        <table id="accessTable"><thead><tr><th>時刻</th><th>パス</th><th>アカウント</th><th>ユーザーエージェント</th><th>リファラ</th></tr></thead><tbody></tbody></table>
      </div>
    </div>

    <div class="card">
      <h3>localStorage（主要キー）</h3>
      <div id="lsKnown"></div>
    </div>

    <div class="card">
      <h3>localStorage（全て）</h3>
      <div id="lsAll"></div>
    </div>

    <div class="card">
      <h3>リポジトリ内ファイル</h3>
      <p class="muted">サーバー経由で配信している場合のみ取得できます（ファイルが存在すれば表示）。</p>
      <div id="repoFiles"></div>
    </div>

    <div class="card">
      <h3>生データプレビュー / インポート</h3>
      <p><input type="file" id="jsonImport"> <button id="importBtn">読み込んで表示</button></p>
      <textarea id="raw" placeholder="ここに集約JSONが表示されます"></textarea>
    </div>

    <div class="card danger">
      <h3>注意</h3>
      <p>このページはフロントエンドのみでパスワード保護しています。パスワードはソース内に平文で保存されます。機密データを扱う場合は必ずサーバー側の認証・認可を導入してください。</p>
    </div>
  </div>

<script>
// -- 管理用パスワード（フロントエンド保護）：サーバー保護の代替ではありません
const ADMIN_PASSWORD = 'cqqdx0ky';

const knownKeys = [
  'kiroku_lot_cards_v1',
  'kiroku_lot_cards_results_v1',
  'kiroku_lot_cards_results_history_v1',
  'kiroku_lot_tests_v1',
  'kiroku_lot_templates_v1'
];

function el(id){return document.getElementById(id)}

function safeParse(s){try{return JSON.parse(s)}catch(e){return s}}

async function fetchIfExists(path){
  try{
    const r = await fetch(path,{cache:'no-store'});
    if(!r.ok) return null;
    const t = await r.text();
    try{return JSON.parse(t)}catch(e){return t}
  }catch(e){return null}
}

async function collectData(){
  const data = {collectedAt: new Date().toISOString(), localStorage:{}, files:{}};
  for(let i=0;i<localStorage.length;i++){
    const key = localStorage.key(i);
    try{data.localStorage[key]=safeParse(localStorage.getItem(key))}catch(e){data.localStorage[key]=localStorage.getItem(key)}
  }
  // try fetch repo files (if served over HTTP)
  const paths = ['/registry.json','/registry.json.bak','/firebase-config.js','/firebase-config.sample.js'];
  for(const p of paths){
    const v = await fetchIfExists(p);
    if(v!==null) data.files[p]=v;
  }
  return data;
}

function renderSummary(data){
  const ds = data.localStorage;
  const knownCounts = {};
  for(const k of knownKeys){ knownCounts[k]= ds[k] ? (Array.isArray(ds[k])? ds[k].length : (Object.keys(ds[k]||{}).length || (typeof ds[k] === 'string'? ds[k].length : 1))) : 0 }
  const html = ['<ul>'];
  for(const k of Object.keys(knownCounts)) html.push(`<li><strong>${k}</strong>: ${JSON.stringify(knownCounts[k])}</li>`);
  html.push(`<li>localStorage 全キー数: ${Object.keys(ds).length}</li>`);
  html.push('</ul>');
  el('summary').innerHTML = html.join('\n');
}

function renderLsKnown(data){
  const ds = data.localStorage; const container = el('lsKnown');
  container.innerHTML = '';
  for(const k of knownKeys){
    const v = ds[k]===undefined? '<em>なし</em>' : `<pre>${escapeHtml(JSON.stringify(ds[k],null,2))}</pre>`;
    const box = document.createElement('div'); box.className=''; box.innerHTML = `<h4>${k}</h4>${v}`; container.appendChild(box);
  }
}

function renderLsAll(data){
  const container = el('lsAll'); container.innerHTML='';
  const table = document.createElement('table');
  table.innerHTML = '<thead><tr><th>key</th><th>value (preview)</th></tr></thead>';
  const tbody = document.createElement('tbody');
  for(const k of Object.keys(data.localStorage).sort()){
    const v = data.localStorage[k];
    const s = typeof v === 'string' ? v : JSON.stringify(v);
    const preview = escapeHtml((s||'').slice(0,200));
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${escapeHtml(k)}</td><td><code>${preview}${s.length>200? '…':''}</code></td>`;
    tbody.appendChild(tr);
  }
  table.appendChild(tbody); container.appendChild(table);
}

function renderFiles(data){
  const container = el('repoFiles'); container.innerHTML='';
  if(!data.files || Object.keys(data.files).length===0){ container.innerHTML = '<p class="muted">サーバー上に該当ファイルが見つかりませんでした（直接ファイルを配信している場合にのみ取得可）</p>'; return }
  for(const k of Object.keys(data.files)){
    const pre = document.createElement('pre'); pre.textContent = typeof data.files[k] === 'string' ? data.files[k] : JSON.stringify(data.files[k],null,2);
    const box = document.createElement('div'); box.innerHTML = `<h4>${escapeHtml(k)}</h4>`; box.appendChild(pre); container.appendChild(box);
  }
}

function aggregateUserStats(data){
  const dst = el('usersAggregate'); dst.innerHTML = '';
  const ls = data.localStorage || {};
  // candidate keys that may contain results/history
  const candidateKeys = ['kiroku_lot_cards_results_history_v1','kiroku_lot_cards_results_v1','kiroku_lot_tests_v1'];
  const entries = [];
  for(const k of candidateKeys){
    if(!(k in ls)) continue;
    const raw = ls[k];
    if(Array.isArray(raw)){
      for(const it of raw) entries.push({source:k,record:it});
    }else if(typeof raw === 'object' && raw !== null){
      // if object is a map of timestamps or ids -> push values
      for(const prop of Object.keys(raw)){
        entries.push({source:k, record: raw[prop]});
      }
    }else{
      // skip non-structured
    }
  }

  if(entries.length === 0){ dst.innerHTML = '<p class="muted">集計可能な結果履歴が見つかりません。</p>'; return }

  // normalize records and group by user-like key
  const users = {};
  function findUserField(r){
    if(!r || typeof r !== 'object') return null;
    const candidates = ['user','uid','userId','owner','author','name','displayName','email','createdBy'];
    for(const c of candidates) if(c in r) return r[c];
    // sometimes embedded
    if(r.meta && typeof r.meta === 'object'){
      for(const c of candidates) if(c in r.meta) return r.meta[c];
    }
    return null;
  }
  function findScoreField(r){
    if(!r || typeof r !== 'object') return null;
    const cands = ['score','percent','percentage','percentCorrect','correct','right'];
    for(const c of cands) if(c in r) return r[c];
    // derived fields
    if('correct' in r && 'total' in r){
      const c = Number(r.correct), t = Number(r.total); if(!isNaN(c) && !isNaN(t) && t>0) return Math.round(c / t * 100);
    }
    return null;
  }

  for(const it of entries){
    const r = it.record;
    const user = findUserField(r) || 'unknown';
    const score = findScoreField(r);
    const at = r && (r.at || r.time || r.createdAt || r.ts) ? (r.at||r.time||r.createdAt||r.ts) : null;
    const ukey = String(user);
    users[ukey] = users[ukey] || {count:0,scores:[],lastAt:null};
    users[ukey].count += 1;
    if(typeof score === 'number' || (typeof score === 'string' && !isNaN(Number(score)))){
      users[ukey].scores.push(Number(score));
    }
    if(at){
      const prev = users[ukey].lastAt ? new Date(users[ukey].lastAt) : null;
      const cur = new Date(at);
      if(!isNaN(cur.getTime()) && (!prev || cur > prev)) users[ukey].lastAt = cur.toISOString();
    }
  }

  // render table
  const table = document.createElement('table');
  table.innerHTML = '<thead><tr><th>ユーザー</th><th>エントリ数</th><th>最新スコア</th><th>平均スコア</th><th>最終更新</th></tr></thead>';
  const tb = document.createElement('tbody');
  for(const u of Object.keys(users).sort()){
    const info = users[u];
    const latest = info.scores.length ? info.scores[info.scores.length-1] : '';
    const avg = info.scores.length ? (Math.round(info.scores.reduce((a,b)=>a+b,0)/info.scores.length*100)/100) : '';
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${escapeHtml(u)}</td><td>${info.count}</td><td>${escapeHtml(String(latest))}</td><td>${escapeHtml(String(avg))}</td><td>${escapeHtml(String(info.lastAt||''))}</td>`;
    tb.appendChild(tr);
  }
  table.appendChild(tb); dst.appendChild(table);
}

function escapeHtml(s){ if(typeof s !== 'string') s = String(s); return s.replace(/[&<>\"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;', '"':'&quot;'}[c])); }

async function refreshAndRender(){
  el('raw').value = '読み込み中…';
  const data = await collectData();
  el('raw').value = JSON.stringify(data,null,2);
  renderSummary(data); renderLsKnown(data); renderLsAll(data); renderFiles(data);
  try{ aggregateUserStats(data); }catch(e){ console.error('aggregateUserStats error', e); }
  return data;
}

// ----------------------
// Ping loop & chart
// ----------------------
const PING_KEY = 'admin_ping_history_v1';
let pingHistory = [];
let pingInterval = null;
const PING_MAX = 120; // keep last N entries

function loadPingHistory(){
  try{ const v = localStorage.getItem(PING_KEY); if(v) pingHistory = JSON.parse(v); }catch(e){ pingHistory = []; }
}
function savePingHistory(){ try{ localStorage.setItem(PING_KEY, JSON.stringify(pingHistory.slice(-PING_MAX))); }catch(e){} }

async function doPing(){
  const statusEl = el('pingStatus');
  const start = performance.now();
  let ok=false, status=null, elapsed=null;
  try{
    // append timestamp to avoid cached responses
    const url = window.location.origin + '/?healthcheck=' + Date.now();
    const r = await fetch(url, {cache:'no-store', mode:'same-origin'});
    elapsed = Math.round(performance.now() - start);
    ok = r.ok; status = r.status;
  }catch(e){
    elapsed = null; ok = false; status = 'ERR';
  }
  const rec = {t: Date.now(), ms: elapsed, ok: !!ok, status};
  pingHistory.push(rec); if(pingHistory.length>PING_MAX) pingHistory.shift(); savePingHistory(); renderPingChart(); renderPingStats();
  statusEl.textContent = `last: ${elapsed!==null? elapsed+' ms' : 'failed'} (${status})`;
}

function startPingLoop(){ if(pingInterval) return; pingInterval = setInterval(doPing, 10000); el('togglePing').textContent='停止'; el('pingStatus').textContent='自動監視中'; }
function stopPingLoop(){ if(!pingInterval) return; clearInterval(pingInterval); pingInterval=null; el('togglePing').textContent='開始'; el('pingStatus').textContent='停止中'; }

function renderPingStats(){
  const s = el('pingStats'); if(!s) return;
  const okCount = pingHistory.filter(p=>p.ok).length; const total = pingHistory.length;
  const avg = pingHistory.filter(p=>p.ms!==null).map(p=>p.ms).reduce((a,b)=>a+b,0) / Math.max(1,pingHistory.filter(p=>p.ms!==null).length);
  s.innerHTML = `<strong>取得数:</strong> ${total}  <strong>成功:</strong> ${okCount}  <strong>成功率:</strong> ${total? Math.round(okCount/total*100) : 0}%  <strong>平均応答:</strong> ${isFinite(avg)? Math.round(avg)+' ms' : '-'}`;
}

function renderPingChart(){
  const c = document.getElementById('pingChart'); if(!c) return; const ctx = c.getContext('2d');
  const w = c.width; const h = c.height; ctx.clearRect(0,0,w,h);
  const arr = pingHistory.slice(-100);
  if(arr.length===0){ ctx.fillStyle='#f6f6f6'; ctx.fillRect(0,0,w,h); ctx.fillStyle='#666'; ctx.fillText('no data', 10,20); return }
  const max = Math.max(200, ...arr.map(a=>a.ms||0));
  // draw grid
  ctx.fillStyle = '#fff'; ctx.fillRect(0,0,w,h);
  ctx.strokeStyle = '#eee'; ctx.lineWidth=1;
  for(let y=0;y<5;y++){ const yy = (h/4)*y + 10; ctx.beginPath(); ctx.moveTo(0,yy); ctx.lineTo(w,yy); ctx.stroke(); }
  // draw line
  ctx.beginPath();
  for(let i=0;i<arr.length;i++){
    const x = i / (arr.length-1||1) * (w-20) + 10;
    const v = arr[i].ms || 0; const y = h - 10 - (v / max) * (h-20);
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.strokeStyle = '#0b76ef'; ctx.lineWidth=2; ctx.stroke();
  // dots
  for(let i=0;i<arr.length;i++){
    const x = i / (arr.length-1||1) * (w-20) + 10;
    const v = arr[i].ms || 0; const y = h - 10 - (v / max) * (h-20);
    ctx.beginPath(); ctx.arc(x,y,2,0,Math.PI*2); ctx.fillStyle = arr[i].ok? '#0b76ef' : '#e04b4b'; ctx.fill();
  }
}

function renderClientStats(){
  const elc = document.getElementById('clientStats'); if(!elc) return;
  const parts = [];
  parts.push(`<strong>userAgent:</strong> ${escapeHtml(navigator.userAgent)}`);
  if('hardwareConcurrency' in navigator) parts.push(`<strong>CPU (logical cores):</strong> ${navigator.hardwareConcurrency}`);
  if('deviceMemory' in navigator) parts.push(`<strong>deviceMemory (GB, approx):</strong> ${navigator.deviceMemory}`);
  if('memory' in performance){
    try{
      const m = performance.memory;
      parts.push(`<strong>JS heap:</strong> used ${Math.round(m.usedJSHeapSize/1024/1024)} MB / total ${Math.round(m.totalJSHeapSize/1024/1024)} MB (limit ${Math.round(m.jsHeapSizeLimit/1024/1024)} MB)`);
    }catch(e){}
  }
  elc.innerHTML = '<div style="font-family:monospace;white-space:pre-wrap">' + parts.join('\n') + '</div>';
}

// wire ping controls
loadPingHistory(); renderPingChart(); renderPingStats(); renderClientStats();
el('pingManual').addEventListener('click', ()=>{ doPing(); });
el('togglePing').addEventListener('click', ()=>{ if(pingInterval) stopPingLoop(); else startPingLoop(); });
// start by default when admin dashboard is visible
// if dashboard already visible, start loop
if(!document.getElementById('dashboard').classList.contains('hidden')) startPingLoop();

// ----------------------
// Access log rendering
// ----------------------
function renderAccessLogs(data){
  const ls = data.localStorage || {};
  const arr = ls['kiroku_access_logs_v1'] || [];
  const counts = {};
  arr.forEach(e => { counts[e.path] = (counts[e.path]||0) + 1; });
  const countsEl = el('accessCounts'); countsEl.innerHTML = '';
  const tbl = document.createElement('table'); tbl.style.width='100%'; tbl.innerHTML = '<thead><tr><th>パス</th><th>アクセス数</th></tr></thead>';
  const tb = document.createElement('tbody');
  Object.keys(counts).sort((a,b)=>counts[b]-counts[a]).forEach(p=>{ const tr = document.createElement('tr'); tr.innerHTML = `<td>${escapeHtml(p)}</td><td>${counts[p]}</td>`; tb.appendChild(tr); });
  tbl.appendChild(tb); countsEl.appendChild(tbl);

  // fill recent table
  const tableBody = document.querySelector('#accessTable tbody'); if(!tableBody) return;
  tableBody.innerHTML = '';
  const recent = arr.slice(-200).reverse();
  recent.forEach(e=>{
    const d = new Date(e.ts);
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${escapeHtml(d.toLocaleString())}</td><td>${escapeHtml(e.path||'')}</td><td>${escapeHtml(String(e.accountId||''))}</td><td style="max-width:320px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis">${escapeHtml(e.ua||'')}</td><td>${escapeHtml(e.ref||'')}</td>`;
    tableBody.appendChild(tr);
  });
  el('accessSummary').textContent = `総エントリ: ${arr.length}`;
}

function downloadAccessCsv(){
  const raw = localStorage.getItem('kiroku_access_logs_v1');
  const arr = raw ? JSON.parse(raw) : [];
  let csv = 'ts,iso,path,accountId,ua,ref\n';
  arr.forEach(e=>{
    const iso = new Date(e.ts).toISOString();
    const line = [e.ts, iso, `"${(e.path||'').replace(/"/g,'""')}")`, `"${String(e.accountId||'').replace(/"/g,'""')}")`, `"${(e.ua||'').replace(/"/g,'""')}")`, `"${(e.ref||'').replace(/"/g,'""')}")`].join(',');
    csv += line + '\n';
  });
  const blob = new Blob([csv],{type:'text/csv'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'access_logs_'+(new Date().toISOString())+'.csv'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
}

el('refreshAccess').addEventListener('click', async ()=>{ const d = await refreshAndRender(); renderAccessLogs(d); });
el('clearAccess').addEventListener('click', ()=>{ if(!confirm('アクセスログを本当にクリアしますか？')) return; localStorage.removeItem('kiroku_access_logs_v1'); refreshAndRender(); });
el('downloadAccess').addEventListener('click', ()=>{ downloadAccessCsv(); });
el('fetchServerLogs').addEventListener('click', async ()=>{
  try{
    // include admin secret header if provided (kept in memory when logging in)
    const headers = { 'Accept': 'application/json' };
    const secret = window.__adminSecret || null;
    if(!secret){
      // ask admin to enter secret (not stored persistently)
      const v = prompt('サーバーログ取得用の管理シークレットを入力してください');
      if(!v) return alert('シークレットが必要です');
      window.__adminSecret = v;
    }
    headers['x-admin-secret'] = window.__adminSecret;
    const r = await fetch('/.netlify/functions/log-access', { headers });
    if(!r.ok) return alert('サーバーログの取得に失敗しました: ' + r.status);
    const json = await r.json();
    // show server logs in raw textarea as well
    el('raw').value = JSON.stringify({ server: json }, null, 2);
    // render counts and table with server logs
    const data = { localStorage: {} };
    data.localStorage['server_access_logs'] = json;
    renderAccessLogs(data);
  }catch(e){ alert('サーバーログ取得中にエラー: ' + e.message); }
});

function downloadJson(obj){
  const blob = new Blob([JSON.stringify(obj,null,2)],{type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'kiroku_lot_admin_export_'+(new Date().toISOString())+'.json'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
}

// -- イベント
el('loginBtn').addEventListener('click', ()=>{
  const v = el('pw').value || '';
  if(v === ADMIN_PASSWORD){
    document.getElementById('loginCard').classList.add('hidden');
    document.getElementById('dashboard').classList.remove('hidden');
    refreshAndRender();
  }else{
    alert('パスワードが違います');
  }
});

el('logoutBtn').addEventListener('click', ()=>{ location.reload(); });
el('refreshBtn').addEventListener('click', ()=>{ refreshAndRender(); });
el('downloadBtn').addEventListener('click', async ()=>{ const d = await collectData(); downloadJson(d); });
el('importBtn').addEventListener('click', ()=>{
  const f = el('jsonImport').files[0];
  if(!f){ alert('ファイルを選択してください'); return }
  const r = new FileReader(); r.onload = e => { try{ const parsed = JSON.parse(e.target.result); el('raw').value = JSON.stringify(parsed,null,2); }catch(err){ alert('JSONとして読み込めません: '+err.message) } }; r.readAsText(f);
});

// allow Enter to submit password
el('pw').addEventListener('keydown', (e)=>{ if(e.key === 'Enter'){ el('loginBtn').click(); } });

</script>
</body>
</html>