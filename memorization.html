<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="mobile-web-app-capable" content="yes" />
  <title>暗記モード - テスト点数記録表</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <main class="container">
    <header class="site-header card">
      <div class="header-left">
        <h1>暗記モード</h1>
        <p class="subtitle">暗記カード（デッキ）を作成し、学習モードと穴埋めテストを切り替えられます</p>
      </div>
      <nav style="display:flex;gap:12px;align-items:center;margin-left:auto">
        <a id="openMemHeaderBtn" href="memorization.html" class="btn">暗記</a>
        <a id="openResultsBtn" class="btn" href="index.html">点数記録</a>
        <a href="timer.html" class="btn">タイマー</a>
        <button type="button" id="toggleEditBtn" class="btn">編集</button>
      </nav>
      <div class="auth-controls" style="display:flex;gap:8px;align-items:center">
        <button id="musicBtn" class="btn" style="background:linear-gradient(135deg,#ff66aa 0%,#ff4488 100%)">
          <span style="display:flex;align-items:center;gap:6px">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/></svg>
            音楽
          </span>
        </button>
        <a id="loginLink" href="login.html" class="btn" style="display:none">ログイン</a>
        <button id="logoutBtn" class="btn" style="display:none">ログアウト</button>
        <span id="authUser" style="display:none;color:var(--muted);font-size:0.85rem"></span>
      </div>
      <!-- Clock Display in Header -->
      <div class="clock-display">
        <div class="clock-time" id="clockTime">00:00:00</div>
        <div class="clock-date" id="clockDate">2024/01/01</div>
        <div class="clock-runtime" id="clockRuntime">runtime 0:00</div>
      </div>
    </header>

  <section class="card" id="topControls">
      <div style="display:flex;gap:12px;align-items:center;flex-wrap:wrap">
        <label style="color:var(--muted);font-size:0.85rem">デッキ
          <select id="deckSelect" style="margin-left:8px;background:rgba(20, 20, 30, 0.6);color:#e8e8f0;border:1px solid var(--input-border);border-radius:8px;padding:8px"></select>
        </label>
        
        <input id="newDeckName" placeholder="新しいデッキ名を入力" style="flex:1;max-width:250px" />
        <button type="button" id="createDeckBtn" class="btn">作成</button>
        <button type="button" id="deleteDeckBtn" class="btn danger">削除</button>
        <button type="button" id="shareDeckBtn" class="btn">共有</button>
        <div style="margin-left:auto;display:flex;gap:12px;align-items:center">
          <button type="button" id="learnModeBtn" class="btn">学習</button>
          <button type="button" id="testModeBtn" class="btn">テスト</button>
        </div>
      </div>
    </section>

  <section class="card" id="cardRegister">
      <h3>カード登録</h3>
      <p class="subtitle">表（出題）と裏（解答）を入力。穴埋め箇所は表に <strong>()</strong> を挿入してください。裏が複数の空欄に対応する場合は <code>||</code> で区切ってください（例: 答1||答2）。</p>
      <div style="display:flex;gap:12px;flex-direction:column">
        <textarea id="cardFront" placeholder="表（問題）を入力: 例）日本の首都は () です" rows="3" style="background:rgba(20, 20, 30, 0.6);color:#e8e8f0;border:1px solid var(--input-border);border-radius:8px;padding:10px"></textarea>
        <textarea id="cardBack" placeholder="裏（解答）。複数は改行・カンマ・スペースでも区切れます（例: 東京 大阪）" rows="2" style="background:rgba(20, 20, 30, 0.6);color:#e8e8f0;border:1px solid var(--input-border);border-radius:8px;padding:10px"></textarea>
        <div style="display:flex;gap:12px;align-items:center">
          <button type="button" id="insertBlankBtn" class="btn">空欄挿入</button>
          <button type="button" id="clearCardBtn" class="btn">クリア</button>
          <button type="button" id="saveCardBtn" class="btn">保存</button>
        </div>
      </div>
    </section>

    <section class="card" id="deckArea">
      <h3>カード一覧</h3>
      <div id="cardsList" style="display:flex;flex-direction:column;gap:8px"></div>
    </section>

    <section class="card" id="studyArea" style="display:none;text-align:center">
      <div id="studyCard" style="padding:24px;font-size:2.6rem;border-radius:8px;border:1px solid rgba(255,102,170,0.2);background:rgba(40,40,60,0.6);min-height:calc(100vh - 200px);display:flex;flex-direction:column;justify-content:center;align-items:center;width:100%">
        <div id="studyFront" style="font-weight:700;margin-bottom:12px;color:#fff">表</div>
        <div id="studyBack" style="color:var(--muted);display:none">裏</div>
      </div>
      <div style="margin-top:12px;display:flex;gap:8px;justify-content:center;flex-wrap:wrap">
  <button type="button" id="revealBtn" class="btn">答えを見る</button>
  <button type="button" id="prevBtn" class="btn">前へ</button>
  <button type="button" id="nextBtn" class="btn">次へ</button>
      </div>
      <div id="progress" style="margin-top:8px;color:var(--muted)"></div>
    </section>

    <section class="card" id="testArea" style="display:none;text-align:center">
      <div id="testCard" style="padding:24px;font-size:2.6rem;border-radius:8px;border:1px solid rgba(255,102,170,0.2);background:rgba(40,40,60,0.6);min-height:calc(100vh - 240px);display:flex;flex-direction:column;justify-content:center;align-items:center;width:100%">
        <div id="testFront" style="font-weight:700;margin-bottom:12px;color:#fff"></div>
        <div id="testInputs" style="margin-top:8px"></div>
      </div>
      <div style="margin-top:12px;display:flex;gap:8px;justify-content:center;flex-wrap:wrap">
  <button type="button" id="testPrevBtn" class="btn">前へ</button>
      </div>
      <div id="testResult" style="margin-top:8px;color:var(--muted)"></div>
      <div id="testSummary" style="display:none;margin-top:16px;text-align:center">
        <div style="font-size:1.1rem">正答率: <strong id="summaryPercent"></strong>% （前回: <span id="previousPercent">-</span>）</div>
        <canvas id="resultChart" width="220" height="220" style="margin-top:12px"></canvas>
      </div>
    </section>

  <div id="feedbackOverlay" style="position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:9999;font-size:8rem;pointer-events:none">
    <div id="feedbackEmoji" style="filter:drop-shadow(0 6px 30px rgba(0,0,0,0.2));">⭕️</div>
  </div>

  </main>

  <script src="music-player.js"></script>
  <script src="score-system.js"></script>
  <script>
  // Music button
  document.getElementById('musicBtn')?.addEventListener('click', () => {
    if (window.MusicPlayer) {
      window.MusicPlayer.showDialog();
    }
  });

  (function(){
    // Clock functionality - Initialize immediately
    let appStartTime = Date.now();
    
    function formatRuntime(ms){
      const sec = Math.floor(ms / 1000);
      const min = Math.floor(sec / 60);
      const hr = Math.floor(min / 60);
      if(hr > 0) return `${hr}:${String(min % 60).padStart(2, '0')}:${String(sec % 60).padStart(2, '0')}`;
      return `${min}:${String(sec % 60).padStart(2, '0')}`;
    }
    
    function updateClock(){
      const now = new Date();
      const timeEl = document.getElementById('clockTime');
      const dateEl = document.getElementById('clockDate');
      const runtimeEl = document.getElementById('clockRuntime');
      
      if(timeEl){
        const hours = String(now.getHours()).padStart(2, '0');
        const minutes = String(now.getMinutes()).padStart(2, '0');
        const seconds = String(now.getSeconds()).padStart(2, '0');
        timeEl.textContent = `${hours}:${minutes}:${seconds}`;
      }
      if(dateEl){
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        const weekdays = ['日', '月', '火', '水', '木', '金', '土'];
        const weekday = weekdays[now.getDay()];
        dateEl.textContent = `${year}/${month}/${day} (${weekday})`;
      }
      if(runtimeEl){
        const runtime = Date.now() - appStartTime;
        runtimeEl.textContent = `runtime ${formatRuntime(runtime)}`;
      }
    }
    
    // Start clock immediately
    updateClock();
    setInterval(updateClock, 1000);

    const LS_KEY = 'kiroku_lot_cards_v1';
    function uid(){return Math.random().toString(36).slice(2,9);}    
    function load(){ try{ const r=localStorage.getItem(LS_KEY); return r?JSON.parse(r):{decks:[]}; }catch(e){return {decks:[]};} }
    function save(data){ try{ localStorage.setItem(LS_KEY, JSON.stringify(data)); }catch(e){}
    }

    let store = load();
    const deckSelect = document.getElementById('deckSelect');
    const createDeckBtn = document.getElementById('createDeckBtn');
    const deleteDeckBtn = document.getElementById('deleteDeckBtn');
    const newDeckName = document.getElementById('newDeckName');
    const cardFront = document.getElementById('cardFront');
    const cardBack = document.getElementById('cardBack');
    const insertBlankBtn = document.getElementById('insertBlankBtn');
    const saveCardBtn = document.getElementById('saveCardBtn');
    const clearCardBtn = document.getElementById('clearCardBtn');
    const cardsList = document.getElementById('cardsList');
    const studyArea = document.getElementById('studyArea');
    const testArea = document.getElementById('testArea');
    const studyFront = document.getElementById('studyFront');
    const studyBack = document.getElementById('studyBack');
    const revealBtn = document.getElementById('revealBtn');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const progressEl = document.getElementById('progress');
  const testFront = document.getElementById('testFront');
  const testInputs = document.getElementById('testInputs');
  const testResult = document.getElementById('testResult');

  // page-local toast notification
  function notify(msg){ try{ let el = document.getElementById('kl_toast_mem'); if(!el){ el = document.createElement('div'); el.id='kl_toast_mem'; el.style.position='fixed'; el.style.right='12px'; el.style.top='12px'; el.style.zIndex=9999; document.body.appendChild(el); } const item = document.createElement('div'); item.textContent = msg; item.style.background = '#e6fffa'; item.style.color = '#0f172a'; item.style.padding = '8px 12px'; item.style.marginTop = '8px'; item.style.borderRadius = '6px'; item.style.boxShadow = '0 2px 6px rgba(0,0,0,0.08)'; el.appendChild(item); setTimeout(()=>{ item.style.opacity='0'; setTimeout(()=>item.remove(),300); },2400); }catch(e){ console.warn('notify', e); } }

  // mode buttons (radio inputs were removed; use buttons)
  const learnModeBtn = document.getElementById('learnModeBtn');
  const testModeBtn = document.getElementById('testModeBtn');
  let currentMode = 'learn';
  const topControls = document.getElementById('topControls');
  const cardRegister = document.getElementById('cardRegister');
  const openMemHeaderBtn = document.getElementById('openMemHeaderBtn');
  const testSummary = document.getElementById('testSummary');
  const summaryPercent = document.getElementById('summaryPercent');
  const previousPercent = document.getElementById('previousPercent');
  const resultChart = document.getElementById('resultChart');
  const feedbackOverlay = document.getElementById('feedbackOverlay');
  const feedbackEmoji = document.getElementById('feedbackEmoji');

  const RESULTS_KEY = 'kiroku_lot_cards_results_v1';
  function loadResults(){ try{ const r = localStorage.getItem(RESULTS_KEY); return r?JSON.parse(r):{}; }catch(e){return{};} }
  function saveResults(obj){ try{ localStorage.setItem(RESULTS_KEY, JSON.stringify(obj)); }catch(e){} }
  let resultsStore = loadResults();

  let testSession = null; // {total, correct, seen}
  // detect url param to show edit UI when coming from results page
  const urlParams = new URLSearchParams(window.location.search);
  const showEditOnLoad = urlParams.get('edit') === '1';
  let isEditing = false;
  const toggleEditBtn = document.getElementById('toggleEditBtn');
    if(toggleEditBtn) toggleEditBtn.addEventListener('click', ()=>{
      // Enter edit mode
      isEditing = true;
      topControls.style.display = 'block'; cardRegister.style.display='block'; document.getElementById('deckArea').style.display='block'; studyArea.style.display='none'; testArea.style.display='none';
      // hide header edit button while editing
      toggleEditBtn.style.display = 'none';
      if(openMemHeaderBtn) openMemHeaderBtn.style.display = 'none';
      updateOpenResultsBtn();
    });

    let currentDeckId = null;
    let currentIndex = 0;
    let deckCards = [];
  let editingCardIndex = null;

    function renderDeckSelect(){ deckSelect.innerHTML = ''; store.decks.forEach(d=>{ const o=document.createElement('option'); o.value=d.id; o.textContent=d.name; deckSelect.appendChild(o); }); if(deckSelect.options.length) deckSelect.value = deckSelect.options[0].value; currentDeckId = deckSelect.value; loadDeck(); }

    function loadDeck(){ const d = store.decks.find(x=>x.id===deckSelect.value); if(!d){ deckCards=[]; cardsList.innerHTML=''; currentDeckId=null; return;} currentDeckId=d.id; deckCards=d.cards||[]; renderCardsList(); }

    function showEditUI(deckId){
      isEditing = true;
      topControls.style.display = 'block'; cardRegister.style.display = 'block'; document.getElementById('deckArea').style.display = 'block';
      studyArea.style.display = 'none'; testArea.style.display = 'none';
      if(openMemHeaderBtn) openMemHeaderBtn.style.display = 'none';
      if(deckId){ try{ deckSelect.value = deckId; }catch(e){} }
      loadDeck();
      updateOpenResultsBtn();
    }

    function renderCardsList(){ cardsList.innerHTML=''; deckCards.forEach((c,i)=>{ const el=document.createElement('div'); el.style.display='flex'; el.style.justifyContent='space-between'; el.style.alignItems='center'; el.style.gap='8px'; const left=document.createElement('div'); left.textContent=(i+1)+'. '+(c.front.slice(0,80)); const btns=document.createElement('div'); btns.style.display='flex'; btns.style.gap='6px'; const edit=document.createElement('button'); edit.className='btn'; edit.textContent='編集'; edit.addEventListener('click', ()=>{ 
        // enter inline edit for this card
        editingCardIndex = i;
        cardFront.value = c.front;
        cardBack.value = c.back;
        // show top controls/edit UI if hidden
        isEditing = true;
        topControls.style.display = 'block'; cardRegister.style.display='block'; document.getElementById('deckArea').style.display = 'block';
        // update save button to indicate update
        saveCardBtn.textContent = '更新';
        // hide header edit button while editing
        if(toggleEditBtn) toggleEditBtn.style.display = 'none';
        if(openMemHeaderBtn) openMemHeaderBtn.style.display = 'none';
        updateOpenResultsBtn();
      });
      const del=document.createElement('button'); del.className='btn danger'; del.textContent='削除'; del.addEventListener('click', ()=>{ if(!confirm('カードを削除しますか？'))return; deckCards.splice(i,1); persistDeck(); renderCardsList(); }); btns.appendChild(edit); btns.appendChild(del); el.appendChild(left); el.appendChild(btns); cardsList.appendChild(el); }); }

    function persistDeck(){ const idx = store.decks.findIndex(d=>d.id===currentDeckId); if(idx===-1) return; store.decks[idx].cards = deckCards; save(store); }

    createDeckBtn.addEventListener('click', ()=>{
      const name = newDeckName.value.trim(); if(!name) return alert('デッキ名を入力してください');
      const d = { id: uid(), name, cards: [] }; store.decks.push(d); save(store); newDeckName.value=''; renderDeckSelect(); deckSelect.value = d.id; loadDeck();
    });
    deleteDeckBtn.addEventListener('click', ()=>{
      if(!currentDeckId) return alert('デッキが選択されていません');
      if(!confirm('デッキを削除しますか？この操作は取り消せません')) return;
      store.decks = store.decks.filter(d=>d.id!==currentDeckId); save(store); renderDeckSelect(); loadDeck();
    });

    deckSelect.addEventListener('change', ()=>{ loadDeck(); });

    insertBlankBtn.addEventListener('click', ()=>{
      const el = cardFront; const start = el.selectionStart||0; const end = el.selectionEnd||0; const v = el.value; el.value = v.slice(0,start) + '()' + v.slice(end); el.selectionStart = el.selectionEnd = start + 1; el.focus();
    });

    saveCardBtn.addEventListener('click', ()=>{
      if(!currentDeckId) return alert('先にデッキを選択または作成してください');
      const f = cardFront.value.trim(); const b = cardBack.value.trim(); if(!f) return alert('表を入力してください');
      if(editingCardIndex !== null && typeof editingCardIndex === 'number'){
        // update existing card
        const existing = deckCards[editingCardIndex] || {};
        deckCards[editingCardIndex] = { id: existing.id || uid(), front: f, back: b };
        editingCardIndex = null;
        saveCardBtn.textContent = 'カードを保存';
      } else {
        const card = { id: uid(), front: f, back: b };
        deckCards.push(card);
      }
      persistDeck(); renderCardsList(); cardFront.value=''; cardBack.value='';
      // restore header edit button visibility
      if(toggleEditBtn) toggleEditBtn.style.display = '';
      if(openMemHeaderBtn) openMemHeaderBtn.style.display = '';
      updateOpenResultsBtn();
    });
    clearCardBtn.addEventListener('click', ()=>{ cardFront.value=''; cardBack.value=''; editingCardIndex = null; saveCardBtn.textContent = 'カードを保存'; if(toggleEditBtn) toggleEditBtn.style.display = ''; if(openMemHeaderBtn) openMemHeaderBtn.style.display = ''; updateOpenResultsBtn(); });

  // study mode (full-screen style)
  function showStudy(i){ if(!deckCards.length) return; currentIndex = (i+deckCards.length)%deckCards.length; const c = deckCards[currentIndex]; studyFront.textContent = c.front; studyBack.textContent = c.back; studyBack.style.display='none'; progressEl.textContent = `${currentIndex+1}/${deckCards.length}`; }
  revealBtn.addEventListener('click', ()=>{ 
    studyBack.style.display='block'; 
    // Award score for studying
    if (window.ScoreSystem) {
      window.ScoreSystem.addScore(5, '暗記学習');
    }
  });
    prevBtn.addEventListener('click', ()=>{ showStudy(currentIndex-1); });
    nextBtn.addEventListener('click', ()=>{
      // in learn mode, when advancing past the last card return to index list
      if(currentMode === 'learn'){
        if(currentIndex + 1 >= deckCards.length){
          // 学習完了: カード編集画面に戻す
          topControls.style.display = 'block'; cardRegister.style.display = 'block'; document.getElementById('deckArea').style.display = 'block';
          studyArea.style.display = 'none'; testArea.style.display = 'none';
          return;
        }
        showStudy(currentIndex+1);
      } else {
        showStudy(currentIndex+1);
      }
    });

    // test mode (穴埋め)
    function buildTestForCard(c){ // returns {htmlFront, answers[], blanks}
      // find occurrences of () in front and create inputs
      const parts = c.front.split('()');
      const blanks = Math.max(0, parts.length - 1);
      // parse answers: prefer explicit '||', otherwise try common separators (改行, カンマ, 読点, セミコロン, パイプ), then whitespace
      function parseAnswers(back, expected){
        if(!back) return [];
        if(back.indexOf('||') !== -1) return back.split('||').map(s=>s.trim()).filter(x=>x!=='');
        let parts = back.split(/\s*[\n、,，;；|]\s*/).map(s=>s.trim()).filter(x=>x!=='');
        if(parts.length === 1 && expected > 1){ // try whitespace split if user just typed space-separated
          parts = back.split(/\s+/).map(s=>s.trim()).filter(x=>x!=='');
        }
        return parts;
      }
      const rawAnswers = parseAnswers(c.back||'', blanks);
      // pad or trim to match blanks count (use blanks as source of truth)
      const answers = [];
      for(let i=0;i<blanks;i++) answers.push(rawAnswers[i] || '');
      let html = '';
      for(let i=0;i<parts.length;i++){
        html += '<span>'+escapeHtml(parts[i])+'</span>';
        if(i<blanks) html += `<span class="mem-blank" style="display:inline-block;min-width:80px;padding:6px;border-bottom:2px dashed var(--muted);margin:4px;height:1.2em;vertical-align:middle;text-align:center;color:var(--muted)">(${i+1})</span>`;
      }
      return { htmlFront: html, answers, blanks };
    }
    function escapeHtml(s){ return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

    function showTest(i){ if(!deckCards.length) return; currentIndex = (i+deckCards.length)%deckCards.length; const c = deckCards[currentIndex]; const built = buildTestForCard(c);
      testFront.innerHTML = ''; testFront.appendChild(document.createElement('div')).innerHTML = built.htmlFront;
      testInputs.innerHTML = '';
      // create inputs equal to blanks/answers
      const inputsWrapper = document.createElement('div'); inputsWrapper.style.display='flex'; inputsWrapper.style.gap='8px'; inputsWrapper.style.alignItems='center'; inputsWrapper.style.marginTop='12px'; inputsWrapper.style.width='100%';
      const answerCount = built.answers.length || 0;
      let firstInput = null;
      for(let k=0;k<answerCount;k++){
        const inp = document.createElement('input'); inp.className = 'mem-input'; inp.dataset.idx = k; inp.style.minWidth = '160px'; inp.style.padding='10px'; inp.style.border='2px solid #3b82f6'; inp.style.borderRadius='8px'; inp.style.fontSize='1rem'; inp.placeholder = `空欄 ${k+1}`;
        inputsWrapper.appendChild(inp);
        if(k===0) firstInput = inp;
      }
  // action button (starts as 判定, becomes 次へ after判定)
  const action = document.createElement('button'); action.id = 'mem-action-btn'; action.type='button'; action.className = 'btn'; action.textContent = '判定'; action.style.flex = '0 0 auto';
  inputsWrapper.appendChild(action);
      testInputs.appendChild(inputsWrapper);
      testResult.textContent=''; testSummary.style.display='none';
      // focus first input
      if(firstInput) setTimeout(()=>{ firstInput.focus(); },50);
  // attach handler
  action.onclick = ()=>{ evaluateCurrentAnswer(); };
  // allow Enter key on inputs to submit
  testInputs.querySelectorAll('.mem-input').forEach(inp=> inp.addEventListener('keydown', (e)=>{ if(e.key === 'Enter'){ e.preventDefault(); evaluateCurrentAnswer(); } }));
      // store answers and card metadata for evaluation and results page
      testFront.dataset.answers = JSON.stringify(built.answers);
      testFront.dataset.cardid = c.id || '';
      testFront.dataset.front = c.front || '';
      testFront.dataset.back = c.back || '';
      testFront.dataset.blanks = built.blanks || 0;
    }

    // test mode flow with session tracking, big emoji feedback and final summary
    function showFeedback(isCorrect){ feedbackEmoji.textContent = isCorrect ? '⭕️' : '❌'; feedbackOverlay.style.display = 'flex'; setTimeout(()=>{ feedbackOverlay.style.display = 'none'; }, 800); }

  function startTestSession(){ testSession = { total: deckCards.length, correct: 0, seen: 0, entries: [] }; }

    // evaluate answer typed into the single input and then advance
    function evaluateCurrentAnswer(){ if(!deckCards.length) return; const c = deckCards[currentIndex]; const inputs = Array.from(document.querySelectorAll('#testInputs .mem-input'));
      // read answers computed when building the test (ensures we use blanks-based splitting/padding)
      let answers = [];
      try{ answers = JSON.parse(testFront.dataset.answers || '[]'); }catch(e){ answers = []; }
      const entered = inputs.map(i=>i.value.trim());
      if(entered.length !== answers.length){ testResult.style.color='orange'; testResult.textContent = `空欄数と解答数が一致しません（入力: ${entered.length} 期待: ${answers.length}）。`; return; }
      let correct = 0; for(let i=0;i<answers.length;i++){ if(entered[i] === answers[i]) correct++; }
      const isCorrect = (correct === answers.length);
      // update session
      testSession.seen++; if(isCorrect) testSession.correct++;
      
      // Award score for test
      if (window.ScoreSystem) {
        if (isCorrect) {
          window.ScoreSystem.addScore(10, '暗記テスト正解！');
        }
      }
      
      // record per-card entry for results
      try{
        const entry = { cardId: testFront.dataset.cardid || c.id, front: testFront.dataset.front || c.front, back: testFront.dataset.back || c.back, expected: answers, entered: entered, correct: isCorrect };
        if(!testSession.entries) testSession.entries = [];
        testSession.entries.push(entry);
      }catch(e){ console.warn('record entry failed', e); }
      // show feedback
      showFeedback(isCorrect);
      testResult.style.color = isCorrect ? 'green' : 'red'; testResult.textContent = `正答 ${correct}/${answers.length}`;
      // disable inputs
      inputs.forEach(inp=> inp.disabled = true);
      // reveal correct answers inline
      try{
        const blanksEls = testFront.querySelectorAll('.mem-blank');
        blanksEls.forEach((el, idx)=>{ el.textContent = answers[idx] || ''; el.style.color = 'var(--muted)'; el.style.borderBottom = 'none'; });
      }catch(e){ /* ignore */ }
      // change action button to '次へ' so user advances manually; if last, it will show results
      try{
        const action = document.getElementById('mem-action-btn'); if(action){ action.textContent = (testSession.seen >= testSession.total) ? '結果を見る' : '次へ'; action.onclick = ()=>{ if(testSession.seen >= testSession.total){ showResults(); } else { showTest(currentIndex+1); } }; }
      }catch(e){ }
    }
    document.getElementById('testPrevBtn').addEventListener('click', ()=>{ showTest(currentIndex-1); });

  // mode toggle: when switching to learn/test, hide creation UI and deck list so study/test use full screen
  function updateMode(){ if(isEditing) return; const hasCards = deckCards.length>0; const mode = currentMode || 'learn';
    // ensure header memorization button visible when not editing
    if(openMemHeaderBtn) openMemHeaderBtn.style.display = '';
    // hide edit UI
      topControls.style.display = 'none'; cardRegister.style.display='none'; document.getElementById('deckArea').style.display='none';
      if(mode==='learn'){
        studyArea.style.display = hasCards ? 'block' : 'none';
        testArea.style.display='none';
        // ensure test prev button hidden in learn mode area
        const testPrev = document.getElementById('testPrevBtn'); if(testPrev) testPrev.style.display = 'inline-block';
        if(hasCards) { showStudy(0); }
      } else {
        testArea.style.display = hasCards ? 'block' : 'none';
        studyArea.style.display='none';
        // hide the test "前へ" button during test mode if desired
        const testPrev = document.getElementById('testPrevBtn'); if(testPrev) testPrev.style.display = 'none';
        if(hasCards) { startTestSession(); showTest(0); }
      }
    }
    if(learnModeBtn) learnModeBtn.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation();
      // exit edit mode when switching to learn/test
      isEditing = false;
      // restore header buttons
      if(toggleEditBtn) toggleEditBtn.style.display = '';
      if(openMemHeaderBtn) openMemHeaderBtn.style.display = '';
      currentMode = 'learn'; updateMode();
    });
    if(testModeBtn) testModeBtn.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation();
      isEditing = false;
      if(toggleEditBtn) toggleEditBtn.style.display = '';
      if(openMemHeaderBtn) openMemHeaderBtn.style.display = '';
      currentMode = 'test'; updateMode();
    });

  // init
  renderDeckSelect();
  // handle importDeck param (shared links)
  const importParam = urlParams.get('importDeck');
  if(importParam){
    try{
      function decodeSharedDeck(s){
        try{ const b64 = decodeURIComponent(s); const json = decodeURIComponent(escape(atob(b64))); return JSON.parse(json); }catch(e){ try{ const b64 = decodeURIComponent(s); return JSON.parse(atob(b64)); }catch(err){ return null; } }
      }
      const imported = decodeSharedDeck(importParam);
      if(imported){ imported.id = uid(); imported.name = (imported.name||'共有デッキ') + ' (共有)'; store.decks.push(imported); save(store); renderDeckSelect(); deckSelect.value = imported.id; loadDeck(); notify('共有デッキをインポートしました'); showEditUI(imported.id); }
    }catch(e){ console.warn('import failed', e); }
  }
  // prefer sessionStorage flag (set by showResults) as it's more reliable than query params
  const pendingEdit = sessionStorage.getItem('kiroku_lot_open_edit');
  if(pendingEdit){ try{ sessionStorage.removeItem('kiroku_lot_open_edit'); showEditUI(pendingEdit); }catch(e){ showEditUI(pendingEdit); } }
  else if(showEditOnLoad){ const deckIdFromUrl = urlParams.get('deck'); showEditUI(deckIdFromUrl); }
  else { updateMode(); }

  // wire the header '記録モード' button to open results for current deck
  const openResultsBtn = document.getElementById('openResultsBtn');
  function updateOpenResultsBtn(){
    if(!openResultsBtn) return;
    // ensure anchor has href so navigation works without JS interference
    try{ openResultsBtn.setAttribute('href', 'index.html'); openResultsBtn.title = '点数記録ページに戻る'; openResultsBtn.style.opacity='1'; openResultsBtn.style.pointerEvents='auto'; }catch(e){}
  }
  // update when deck changes
  deckSelect.addEventListener('change', ()=>{ loadDeck(); updateOpenResultsBtn(); });
  updateOpenResultsBtn();
  if(openResultsBtn){ openResultsBtn.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation();
    // clear any pending edit flag
    try{ sessionStorage.removeItem('kiroku_lot_open_edit'); }catch(e){}
    // navigate to the score recording (一覧) page
    window.location.href = 'index.html';
  }); }
  // share current deck to clipboard as a link
  if(shareDeckBtn){ shareDeckBtn.addEventListener('click', async (e)=>{ e.preventDefault(); e.stopPropagation(); if(!currentDeckId){ alert('先にデッキを選択してください'); return; } const deck = store.decks.find(d=>d.id===currentDeckId); if(!deck){ alert('選択中のデッキが見つかりません'); return; } try{ const s = JSON.stringify(deck); const b64 = btoa(unescape(encodeURIComponent(s))); const enc = encodeURIComponent(b64); const link = location.origin + location.pathname + '?importDeck=' + enc; if(navigator.clipboard && navigator.clipboard.writeText){ await navigator.clipboard.writeText(link); notify('共有リンクをクリップボードにコピーしました'); } else { const ta = document.createElement('textarea'); ta.value = link; document.body.appendChild(ta); ta.select(); document.execCommand('copy'); ta.remove(); notify('共有リンクをコピーしました（フォールバック）'); } }catch(err){ console.warn('share failed', err); alert('共有リンクの作成に失敗しました'); } }); }

    // Results display
    function drawResultChart(correct, incorrect){ try{ const c = resultChart.getContext('2d'); const total = correct + incorrect; const angle = (correct/total) * Math.PI * 2; c.clearRect(0,0,resultChart.width,resultChart.height); const cx = resultChart.width/2; const cy = resultChart.height/2; const r = Math.min(cx,cy)-8; // background
        // correct (red)
        c.beginPath(); c.moveTo(cx,cy); c.fillStyle = '#ef4444'; c.arc(cx,cy,r,-Math.PI/2, -Math.PI/2 + angle); c.closePath(); c.fill();
        // incorrect (blue)
        c.beginPath(); c.moveTo(cx,cy); c.fillStyle = '#3b82f6'; c.arc(cx,cy,r,-Math.PI/2 + angle, -Math.PI/2 + Math.PI*2); c.closePath(); c.fill();
      }catch(e){ console.warn('draw chart failed', e); } }

    const RESULTS_HISTORY_KEY = 'kiroku_lot_cards_results_history_v1';
    function loadResultsHistory(){ try{ const r = localStorage.getItem(RESULTS_HISTORY_KEY); return r?JSON.parse(r):{}; }catch(e){return{};} }
    function saveResultsHistory(obj){ try{ localStorage.setItem(RESULTS_HISTORY_KEY, JSON.stringify(obj)); }catch(e){} }

    function showResults(){ if(!testSession) return; const total = testSession.total; const correct = testSession.correct; const incorrect = total - correct; const pct = total? (correct/total*100) : 0; const prev = resultsStore[currentDeckId]; // persist current result
      resultsStore[currentDeckId] = pct; saveResults(resultsStore);
      // append to history
      try{
        const hist = loadResultsHistory(); if(!hist[currentDeckId]) hist[currentDeckId]=[];
        hist[currentDeckId].push({ t: Date.now(), pct: pct });
        // keep recent 100
        if(hist[currentDeckId].length>100) hist[currentDeckId]=hist[currentDeckId].slice(-100);
        saveResultsHistory(hist);
      }catch(e){ console.warn('save history failed', e); }
      // save last result to sessionStorage for the results page
  try{ sessionStorage.setItem('kiroku_lot_last_result', JSON.stringify({ deckId: currentDeckId, pct: pct, prev: typeof prev === 'number' ? prev : null, correct, incorrect, entries: testSession.entries || [] })); }catch(e){}
      // set a flag so the results->memorization flow can open the editor reliably
      try{ sessionStorage.setItem('kiroku_lot_open_edit', currentDeckId); }catch(e){}
      // navigate to results page and request that results page show edit UI link
      window.location.href = 'memorization-results.html?deck=' + encodeURIComponent(currentDeckId) + '&edit=1';
    }

    // Clock update


    // Auth UI
    function updateAuthUI() {
      const accountId = localStorage.getItem('kl_account_id');
      const loginLink = document.getElementById('loginLink');
      const logoutBtn = document.getElementById('logoutBtn');
      const authUser = document.getElementById('authUser');
      
      if (accountId) {
        if (loginLink) loginLink.style.display = 'none';
        if (logoutBtn) logoutBtn.style.display = 'inline-block';
        if (authUser) {
          authUser.textContent = `acct:${accountId}`;
          authUser.style.display = 'inline-block';
        }
      } else {
        if (loginLink) loginLink.style.display = 'inline-block';
        if (logoutBtn) logoutBtn.style.display = 'none';
        if (authUser) authUser.style.display = 'none';
      }
    }

    updateAuthUI();
    const logoutBtn = document.getElementById('logoutBtn');
    if (logoutBtn) {
      logoutBtn.addEventListener('click', () => {
        localStorage.removeItem('kl_account_id');
        updateAuthUI();
        alert('ログアウトしました');
        window.location.reload();
      });
    }
  })();
  </script>
</body>
</html>
