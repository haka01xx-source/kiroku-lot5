<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="mobile-web-app-capable" content="yes" />
  <title>æš—è¨˜ãƒ¢ãƒ¼ãƒ‰ - ãƒ†ã‚¹ãƒˆç‚¹æ•°è¨˜éŒ²è¡¨</title>
  <link rel="stylesheet" href="styles.css" />
  <script>
    window.si = window.si || function () { (window.siq = window.siq || []).push(arguments); };
  </script>
  <script defer src="/_vercel/speed-insights/script.js"></script>
</head>
<body>
  <main class="container">
    <header class="site-header card">
      <div class="header-left">
        <h1>æš—è¨˜ãƒ¢ãƒ¼ãƒ‰</h1>
        <p class="subtitle">æš—è¨˜ã‚«ãƒ¼ãƒ‰ï¼ˆãƒ‡ãƒƒã‚­ï¼‰ã‚’ä½œæˆã—ã€å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰ã¨ç©´åŸ‹ã‚ãƒ†ã‚¹ãƒˆã‚’åˆ‡ã‚Šæ›¿ãˆã‚‰ã‚Œã¾ã™</p>
      </div>
      <nav style="display:flex;gap:12px;align-items:center;margin-left:auto">
        <a id="openMemHeaderBtn" href="memorization.html" class="btn">æš—è¨˜</a>
        <a id="openResultsBtn" class="btn" href="index.html">ç‚¹æ•°è¨˜éŒ²</a>
        <a href="timer.html" class="btn">ã‚¿ã‚¤ãƒãƒ¼</a>
        <a href="leaderboard.html" class="btn">ãƒ©ãƒ³ã‚­ãƒ³ã‚°</a>
        <button type="button" id="toggleEditBtn" class="btn">ç·¨é›†</button>
      </nav>
      <div class="auth-controls" style="display:flex;gap:8px;align-items:center">

        <a id="loginLink" href="login.html" class="btn" style="display:none">ãƒ­ã‚°ã‚¤ãƒ³</a>
        <button id="logoutBtn" class="btn" style="display:none">ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ</button>
        <span id="authUser" style="display:none;color:var(--muted);font-size:0.85rem"></span>
      </div>
      <!-- Clock Display in Header -->
      <div class="clock-display">
        <div class="clock-time" id="clockTime">00:00:00</div>
        <div class="clock-date" id="clockDate">2024/01/01</div>
        <div class="clock-runtime" id="clockRuntime">runtime 0:00</div>
      </div>
    </header>

  <!-- Deck selection screen (Anki-style) -->
  <section class="card" id="deckSelection" style="display:none">
    <h2 style="margin:0 0 24px 0;color:#fff">å˜èªå¸³ã‚’é¸æŠ</h2>
    
    <div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(280px,1fr));gap:16px;margin-bottom:24px" id="deckGrid"></div>
    
    <div style="display:flex;gap:12px;align-items:center;padding-top:16px;border-top:1px solid rgba(255,102,170,0.2)">
      <input id="newDeckName" placeholder="æ–°ã—ã„ãƒ‡ãƒƒã‚­åã‚’å…¥åŠ›" style="flex:1;padding:12px;background:rgba(20, 20, 30, 0.6);color:#e8e8f0;border:1px solid var(--input-border);border-radius:8px;font-size:0.95rem" />
      <button type="button" id="createDeckBtn" class="btn" style="padding:12px 24px;background:linear-gradient(135deg,#ff66aa 0%,#66ccff 100%)">ä½œæˆ</button>
    </div>
  </section>

  <!-- Card editor screen (separate from deck selection) -->
  <section class="card" id="cardEditor" style="display:none">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px">
      <h2 style="margin:0;color:#fff" id="currentDeckName">ãƒ‡ãƒƒã‚­å</h2>
      <div style="display:flex;gap:8px">
        <button type="button" id="backToDeckBtn" class="btn secondary">â† ãƒ‡ãƒƒã‚­é¸æŠ</button>
        <button type="button" id="startLearnBtn" class="btn" style="background:linear-gradient(135deg,#ff66aa 0%,#66ccff 100%)">å­¦ç¿’é–‹å§‹</button>
        <button type="button" id="startTestBtn" class="btn secondary">ãƒ†ã‚¹ãƒˆé–‹å§‹</button>
      </div>
    </div>
    
    <div style="display:flex;flex-direction:column;gap:16px">
      <!-- Card registration -->
      <div style="padding:16px;background:rgba(40,40,60,0.6);border-radius:8px">
        <h3 style="margin:0 0 12px 0;color:#fff">ã‚«ãƒ¼ãƒ‰ç™»éŒ²</h3>
        <p style="color:var(--muted);font-size:0.9rem;margin-bottom:12px">è¡¨ï¼ˆå‡ºé¡Œï¼‰ã¨è£ï¼ˆè§£ç­”ï¼‰ã‚’å…¥åŠ›ã€‚ç©´åŸ‹ã‚ç®‡æ‰€ã¯è¡¨ã« <strong>()</strong> ã‚’æŒ¿å…¥ã—ã¦ãã ã•ã„ã€‚</p>
        <div style="display:flex;gap:12px;flex-direction:column">
          <textarea id="cardFront" placeholder="è¡¨ï¼ˆå•é¡Œï¼‰ã‚’å…¥åŠ›: ä¾‹ï¼‰æ—¥æœ¬ã®é¦–éƒ½ã¯ () ã§ã™" rows="3" style="background:rgba(20, 20, 30, 0.6);color:#e8e8f0;border:1px solid var(--input-border);border-radius:8px;padding:10px"></textarea>
          <textarea id="cardBack" placeholder="è£ï¼ˆè§£ç­”ï¼‰ã€‚è¤‡æ•°ã¯æ”¹è¡Œãƒ»ã‚«ãƒ³ãƒãƒ»ã‚¹ãƒšãƒ¼ã‚¹ã§ã‚‚åŒºåˆ‡ã‚Œã¾ã™ï¼ˆä¾‹: æ±äº¬ å¤§é˜ªï¼‰" rows="2" style="background:rgba(20, 20, 30, 0.6);color:#e8e8f0;border:1px solid var(--input-border);border-radius:8px;padding:10px"></textarea>
          <div style="display:flex;gap:12px;align-items:center">
            <button type="button" id="insertBlankBtn" class="btn secondary">ç©ºæ¬„æŒ¿å…¥</button>
            <button type="button" id="clearCardBtn" class="btn secondary">ã‚¯ãƒªã‚¢</button>
            <button type="button" id="saveCardBtn" class="btn" style="background:linear-gradient(135deg,#ff66aa 0%,#66ccff 100%)">ã‚«ãƒ¼ãƒ‰ã‚’ä¿å­˜</button>
          </div>
        </div>
      </div>
      
      <!-- Card list -->
      <div style="padding:16px;background:rgba(40,40,60,0.6);border-radius:8px">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px">
          <h3 style="margin:0;color:#fff">ã‚«ãƒ¼ãƒ‰ä¸€è¦§ (<span id="cardCount">0</span>æš)</h3>
          <button type="button" id="deleteDeckBtn" class="btn danger">ãƒ‡ãƒƒã‚­ã‚’å‰Šé™¤</button>
        </div>
        <div id="cardsList" style="display:flex;flex-direction:column;gap:8px"></div>
      </div>
    </div>
  </section>

    <!-- Anki-style settings screen (shown before starting) -->
    <section class="card" id="studySettings" style="display:none">
      <h3>ãƒ“ãƒ¥ãƒ¼ã‚¢è¨­å®š</h3>
      <p style="color:var(--muted);font-size:0.9rem;margin-bottom:16px">[Enter]ã§ã‚«ãƒ¼ãƒ‰ã‚’ã‚ãã‚Šã¾ã™ã€‚ãƒ“ãƒ¥ãƒ¼ã‚¢è¨­å®šã¯æš—è¨˜é–‹å§‹æ™‚ã«ç«¯æœ«å†…ã«ä¿å­˜ã•ã‚Œã¾ã™ã€‚</p>
      
      <style>
        .toggle-switch { position: relative; display: inline-block; width: 50px; height: 28px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .toggle-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(255,255,255,0.2); transition: .3s; border-radius: 28px; }
        .toggle-slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .3s; border-radius: 50%; }
        .toggle-switch input:checked + .toggle-slider { background: linear-gradient(135deg, #8080dd 0%, #6060cc 100%); }
        .toggle-switch input:checked + .toggle-slider:before { transform: translateX(22px); }
      </style>
      
      <div style="display:flex;flex-direction:column;gap:8px">
        <label style="display:flex;justify-content:space-between;align-items:center;padding:14px 16px;background:rgba(40,40,60,0.6);border-radius:8px;cursor:pointer">
          <div style="flex:1">
            <div style="color:#fff;font-weight:600;margin-bottom:2px">ã‚¿ãƒƒãƒã§ã‚ãã‚‹</div>
            <div style="color:var(--muted);font-size:0.85rem">ã‚¿ãƒƒãƒã ã‘ã§ã‚«ãƒ¼ãƒ‰ãŒã‚ãã‚Œã¾ã™ã€‚</div>
          </div>
          <label class="toggle-switch">
            <input type="checkbox" id="easyFlip">
            <span class="toggle-slider"></span>
          </label>
        </label>
        
        <label style="display:flex;justify-content:space-between;align-items:center;padding:14px 16px;background:rgba(40,40,60,0.6);border-radius:8px;cursor:pointer">
          <div style="flex:1">
            <div style="color:#fff;font-weight:600;margin-bottom:2px">ãƒã‚§ãƒƒã‚¯æ¸ˆã‚’éè¡¨ç¤º</div>
            <div style="color:var(--muted);font-size:0.85rem">ãƒã‚§ãƒƒã‚¯ã‚’ã¤ã‘ãŸã‚«ãƒ¼ãƒ‰ã‚’éè¡¨ç¤ºã«ã—ã¾ã™ã€‚</div>
          </div>
          <label class="toggle-switch">
            <input type="checkbox" id="hideChecked">
            <span class="toggle-slider"></span>
          </label>
        </label>
        
        <div style="display:flex;justify-content:space-between;align-items:center;padding:14px 16px;background:rgba(40,40,60,0.6);border-radius:8px">
          <div style="flex:1">
            <div style="color:#fff;font-weight:600;margin-bottom:2px">ãƒã‚§ãƒƒã‚¯ã‚’ãƒªã‚»ãƒƒãƒˆ</div>
            <div style="color:var(--muted);font-size:0.85rem">ãƒã‚§ãƒƒã‚¯ã‚’ã™ã¹ã¦ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã€‚</div>
          </div>
          <button type="button" id="resetChecks" class="btn secondary" style="padding:8px 16px">ğŸ§¹</button>
        </div>
        
        <label style="display:flex;justify-content:space-between;align-items:center;padding:14px 16px;background:rgba(40,40,60,0.6);border-radius:8px;cursor:pointer">
          <div style="flex:1">
            <div style="color:#fff;font-weight:600;margin-bottom:2px">ã‚«ãƒ¼ãƒ‰ã‚’è£è¿”ã™</div>
            <div style="color:var(--muted);font-size:0.85rem">ã‚«ãƒ¼ãƒ‰ã®è¡¨è£ã‚’é€†ã«ã—ã¾ã™ã€‚</div>
          </div>
          <label class="toggle-switch">
            <input type="checkbox" id="reverseCards">
            <span class="toggle-slider"></span>
          </label>
        </label>
        
        <label style="display:flex;justify-content:space-between;align-items:center;padding:14px 16px;background:rgba(40,40,60,0.6);border-radius:8px;cursor:pointer">
          <div style="flex:1">
            <div style="color:#fff;font-weight:600;margin-bottom:2px">ã‚«ãƒ¼ãƒ‰ã‚’æ··ãœã‚‹</div>
            <div style="color:var(--muted);font-size:0.85rem">ã‚«ãƒ¼ãƒ‰ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«æ··ãœã¾ã™ã€‚</div>
          </div>
          <label class="toggle-switch">
            <input type="checkbox" id="shuffleCards">
            <span class="toggle-slider"></span>
          </label>
        </label>
        
        <label style="display:flex;justify-content:space-between;align-items:center;padding:14px 16px;background:rgba(40,40,60,0.6);border-radius:8px;cursor:pointer">
          <div style="flex:1">
            <div style="color:#fff;font-weight:600;margin-bottom:2px">ç„¡é™ãƒ«ãƒ¼ãƒ—</div>
            <div style="color:var(--muted);font-size:0.85rem">æœ€å¾Œã«åˆ°é”ã™ã‚‹ã¨è‡ªå‹•ã§æœ€åˆã«æˆ»ã‚Šã¾ã™ã€‚</div>
          </div>
          <label class="toggle-switch">
            <input type="checkbox" id="infiniteLoop">
            <span class="toggle-slider"></span>
          </label>
        </label>
        
        <label style="display:flex;justify-content:space-between;align-items:center;padding:14px 16px;background:rgba(40,40,60,0.6);border-radius:8px;cursor:pointer">
          <div style="flex:1">
            <div style="color:#fff;font-weight:600;margin-bottom:2px">è‡ªå‹•ã§ã‚ãã‚‹</div>
            <div style="color:var(--muted);font-size:0.85rem">ä¸€å®šé–“éš”ã§ã‚«ãƒ¼ãƒ‰ã‚’è‡ªå‹•ã§ã‚ãã‚Šã¾ã™ã€‚</div>
          </div>
          <label class="toggle-switch">
            <input type="checkbox" id="autoFlip">
            <span class="toggle-slider"></span>
          </label>
        </label>
        
        <div id="autoFlipSettings" style="display:none;padding-left:20px">
          <label style="display:flex;justify-content:space-between;align-items:center;padding:12px;background:rgba(40,40,60,0.4);border-radius:8px;margin-bottom:8px">
            <div>
              <div style="color:#fff;font-weight:600;margin-bottom:4px">ã‚ãã‚‹é–“éš” (è¡¨)</div>
              <div style="color:var(--muted);font-size:0.85rem">0ç§’ã«ã™ã‚‹ã¨èª­ã¿ä¸Šã’ã«åˆã‚ã›ã¦ã‚ãã‚Šã¾ã™ã€‚</div>
            </div>
            <div style="display:flex;align-items:center;gap:8px">
              <input type="number" id="autoFlipTime" min="0" max="60" step="0.5" value="3" style="width:80px;padding:8px;background:rgba(20,20,30,0.6);color:#fff;border:1px solid var(--input-border);border-radius:4px">
              <span style="color:var(--muted)">ç§’</span>
            </div>
          </label>
          
          <label style="display:flex;justify-content:space-between;align-items:center;padding:12px;background:rgba(40,40,60,0.4);border-radius:8px">
            <div>
              <div style="color:#fff;font-weight:600;margin-bottom:4px">ã‚ãã‚‹é–“éš” (è£)</div>
              <div style="color:var(--muted);font-size:0.85rem">0ç§’ã«ã™ã‚‹ã¨èª­ã¿ä¸Šã’ã«åˆã‚ã›ã¦ã‚ãã‚Šã¾ã™ã€‚</div>
            </div>
            <div style="display:flex;align-items:center;gap:8px">
              <input type="number" id="autoFlipTime2" min="0" max="60" step="0.5" value="3" style="width:80px;padding:8px;background:rgba(20,20,30,0.6);color:#fff;border:1px solid var(--input-border);border-radius:4px">
              <span style="color:var(--muted)">ç§’</span>
            </div>
          </label>
        </div>
      </div>
      
      <button type="button" id="startStudyBtn" class="btn" style="width:100%;margin-top:24px;padding:16px;font-size:1.1rem;background:linear-gradient(135deg,#ff66aa 0%,#66ccff 100%)">æš—è¨˜ã‚’é–‹å§‹ã™ã‚‹</button>
    </section>

    <!-- Anki-style study screen (shown after starting) -->
    <section class="card" id="studyArea" style="display:none">
      <div id="studyPanel" style="position:relative;width:100%;height:calc(100vh - 200px);display:flex;flex-direction:column">
        <!-- Header -->
        <div style="display:flex;justify-content:space-between;align-items:center;padding:12px;background:rgba(40,40,60,0.6);border-radius:8px 8px 0 0">
          <button type="button" id="pauseStudyBtn" class="btn secondary">â† è¨­å®š</button>
          <div style="color:#fff;font-weight:600">æš—è¨˜ãƒ¢ãƒ¼ãƒ‰</div>
          <button type="button" id="stopStudyBtn" class="btn danger">çµ‚äº†</button>
        </div>
        
        <!-- Card area -->
        <div id="studyCard" style="flex:1;padding:24px;font-size:2.6rem;border-radius:0;border:1px solid rgba(255,102,170,0.2);border-top:none;border-bottom:none;background:rgba(40,40,60,0.6);display:flex;flex-direction:column;justify-content:center;align-items:center;position:relative;cursor:pointer;transition:transform 0.3s ease">
          <div id="studyFront" style="font-weight:700;margin-bottom:12px;color:#fff;text-align:center;max-width:90%">è¡¨</div>
          <div id="studyBack" style="color:var(--muted);display:none;text-align:center;max-width:90%">è£</div>
          
          <!-- Check mark (Anki-style) -->
          <label style="position:absolute;bottom:20px;right:20px;display:flex;align-items:center;justify-content:center;width:60px;height:60px;cursor:pointer">
            <input type="checkbox" id="checkMark" style="display:none">
            <svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="width:100%;height:100%;fill:rgba(255,102,170,0.3);transition:fill 0.3s ease">
              <path d="M469.402,35.492C334.09,110.664,197.114,324.5,197.114,324.5L73.509,184.176L0,254.336l178.732,222.172 l65.15-2.504C327.414,223.414,512,55.539,512,55.539L469.402,35.492z"/>
            </svg>
          </label>
        </div>
        
        <!-- Navigation buttons -->
        <div style="display:flex;justify-content:center;gap:12px;padding:16px;background:rgba(40,40,60,0.6);border:1px solid rgba(255,102,170,0.2);border-top:none;border-bottom:none">
          <button type="button" id="prevCardBtn" class="btn secondary" style="padding:10px 20px">â† å‰ã¸</button>
          <button type="button" id="revealCardBtn" class="btn" style="padding:10px 24px;background:linear-gradient(135deg,#ff66aa 0%,#66ccff 100%)">ç­”ãˆã‚’è¦‹ã‚‹ [Enter]</button>
          <button type="button" id="nextCardBtn" class="btn secondary" style="padding:10px 20px">æ¬¡ã¸ â†’</button>
        </div>
        
        <!-- Status bar -->
        <div style="padding:12px;background:rgba(40,40,60,0.6);border-radius:0 0 8px 8px;border:1px solid rgba(255,102,170,0.2);border-top:none">
          <div style="display:flex;justify-content:center;align-items:center;gap:8px;margin-bottom:8px">
            <div id="progress" style="color:var(--muted);font-size:0.9rem">æš—è¨˜ã‚¹ã‚¿ãƒ¼ãƒˆ</div>
          </div>
          <div id="progressBar" style="width:100%;height:6px;background:rgba(255,255,255,0.1);border-radius:3px;overflow:hidden">
            <div id="progressBarFill" style="height:100%;background:linear-gradient(90deg,#ff66aa 0%,#66ccff 100%);width:0%;transition:width 0.3s ease"></div>
          </div>
        </div>
      </div>
    </section>

    <section class="card" id="testArea" style="display:none;text-align:center">
      <div id="testCard" style="padding:24px;font-size:2.6rem;border-radius:8px;border:1px solid rgba(255,102,170,0.2);background:rgba(40,40,60,0.6);min-height:calc(100vh - 240px);display:flex;flex-direction:column;justify-content:center;align-items:center;width:100%">
        <div id="testFront" style="font-weight:700;margin-bottom:12px;color:#fff"></div>
        <div id="testInputs" style="margin-top:8px"></div>
      </div>
      <div style="margin-top:12px;display:flex;gap:8px;justify-content:center;flex-wrap:wrap">
  <button type="button" id="testPrevBtn" class="btn">å‰ã¸</button>
      </div>
      <div id="testResult" style="margin-top:8px;color:var(--muted)"></div>
      <div id="testSummary" style="display:none;margin-top:16px;text-align:center">
        <div style="font-size:1.1rem">æ­£ç­”ç‡: <strong id="summaryPercent"></strong>% ï¼ˆå‰å›: <span id="previousPercent">-</span>ï¼‰</div>
        <canvas id="resultChart" width="220" height="220" style="margin-top:12px"></canvas>
      </div>
    </section>

  <div id="feedbackOverlay" style="position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:9999;font-size:8rem;pointer-events:none">
    <div id="feedbackEmoji" style="filter:drop-shadow(0 6px 30px rgba(0,0,0,0.2));">â­•ï¸</div>
  </div>

  </main>

  <script src="score-system.js"></script>
  <script>
  // Check login
  if (!localStorage.getItem('kl_account_id')) {
    window.location.href = 'login.html';
  }

  (function(){
    // Clock functionality - Initialize immediately
    let appStartTime = Date.now();
    
    function formatRuntime(ms){
      const sec = Math.floor(ms / 1000);
      const min = Math.floor(sec / 60);
      const hr = Math.floor(min / 60);
      if(hr > 0) return `${hr}:${String(min % 60).padStart(2, '0')}:${String(sec % 60).padStart(2, '0')}`;
      return `${min}:${String(sec % 60).padStart(2, '0')}`;
    }
    
    function updateClock(){
      const now = new Date();
      const timeEl = document.getElementById('clockTime');
      const dateEl = document.getElementById('clockDate');
      const runtimeEl = document.getElementById('clockRuntime');
      
      if(timeEl){
        const hours = String(now.getHours()).padStart(2, '0');
        const minutes = String(now.getMinutes()).padStart(2, '0');
        const seconds = String(now.getSeconds()).padStart(2, '0');
        timeEl.textContent = `${hours}:${minutes}:${seconds}`;
      }
      if(dateEl){
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        const weekdays = ['æ—¥', 'æœˆ', 'ç«', 'æ°´', 'æœ¨', 'é‡‘', 'åœŸ'];
        const weekday = weekdays[now.getDay()];
        dateEl.textContent = `${year}/${month}/${day} (${weekday})`;
      }
      if(runtimeEl){
        const runtime = Date.now() - appStartTime;
        runtimeEl.textContent = `runtime ${formatRuntime(runtime)}`;
      }
    }
    
    // Start clock immediately
    updateClock();
    setInterval(updateClock, 1000);

    const LS_KEY = 'kiroku_lot_cards_v1';
    function uid(){return Math.random().toString(36).slice(2,9);}    
    function load(){ try{ const r=localStorage.getItem(LS_KEY); return r?JSON.parse(r):{decks:[]}; }catch(e){return {decks:[]};} }
    function save(data){ try{ localStorage.setItem(LS_KEY, JSON.stringify(data)); }catch(e){}
    }

    let store = load();
    const deckSelect = document.getElementById('deckSelect');
    const createDeckBtn = document.getElementById('createDeckBtn');
    const deleteDeckBtn = document.getElementById('deleteDeckBtn');
    const newDeckName = document.getElementById('newDeckName');
    const cardFront = document.getElementById('cardFront');
    const cardBack = document.getElementById('cardBack');
    const insertBlankBtn = document.getElementById('insertBlankBtn');
    const saveCardBtn = document.getElementById('saveCardBtn');
    const clearCardBtn = document.getElementById('clearCardBtn');
    const cardsList = document.getElementById('cardsList');
    const studyArea = document.getElementById('studyArea');
    const testArea = document.getElementById('testArea');
    const studyFront = document.getElementById('studyFront');
    const studyBack = document.getElementById('studyBack');
    const revealBtn = document.getElementById('revealBtn');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const progressEl = document.getElementById('progress');
  const testFront = document.getElementById('testFront');
  const testInputs = document.getElementById('testInputs');
  const testResult = document.getElementById('testResult');

  // page-local toast notification
  function notify(msg){ try{ let el = document.getElementById('kl_toast_mem'); if(!el){ el = document.createElement('div'); el.id='kl_toast_mem'; el.style.position='fixed'; el.style.right='12px'; el.style.top='12px'; el.style.zIndex=9999; document.body.appendChild(el); } const item = document.createElement('div'); item.textContent = msg; item.style.background = '#e6fffa'; item.style.color = '#0f172a'; item.style.padding = '8px 12px'; item.style.marginTop = '8px'; item.style.borderRadius = '6px'; item.style.boxShadow = '0 2px 6px rgba(0,0,0,0.08)'; el.appendChild(item); setTimeout(()=>{ item.style.opacity='0'; setTimeout(()=>item.remove(),300); },2400); }catch(e){ console.warn('notify', e); } }

  // mode buttons (radio inputs were removed; use buttons)
  const learnModeBtn = document.getElementById('learnModeBtn');
  const testModeBtn = document.getElementById('testModeBtn');
  let currentMode = 'learn';
  const topControls = document.getElementById('topControls');
  const cardRegister = document.getElementById('cardRegister');
  const openMemHeaderBtn = document.getElementById('openMemHeaderBtn');
  const testSummary = document.getElementById('testSummary');
  const summaryPercent = document.getElementById('summaryPercent');
  const previousPercent = document.getElementById('previousPercent');
  const resultChart = document.getElementById('resultChart');
  const feedbackOverlay = document.getElementById('feedbackOverlay');
  const feedbackEmoji = document.getElementById('feedbackEmoji');

  const RESULTS_KEY = 'kiroku_lot_cards_results_v1';
  function loadResults(){ try{ const r = localStorage.getItem(RESULTS_KEY); return r?JSON.parse(r):{}; }catch(e){return{};} }
  function saveResults(obj){ try{ localStorage.setItem(RESULTS_KEY, JSON.stringify(obj)); }catch(e){} }
  let resultsStore = loadResults();

  let testSession = null; // {total, correct, seen}
  // detect url param to show edit UI when coming from results page
  const urlParams = new URLSearchParams(window.location.search);
  const showEditOnLoad = urlParams.get('edit') === '1';
  let isEditing = false;
  const toggleEditBtn = document.getElementById('toggleEditBtn');
    if(toggleEditBtn) toggleEditBtn.addEventListener('click', ()=>{
      // Enter edit mode
      isEditing = true;
      topControls.style.display = 'block'; cardRegister.style.display='block'; document.getElementById('deckArea').style.display='block'; studyArea.style.display='none'; testArea.style.display='none';
      // hide header edit button while editing
      toggleEditBtn.style.display = 'none';
      if(openMemHeaderBtn) openMemHeaderBtn.style.display = 'none';
      updateOpenResultsBtn();
    });

    let currentDeckId = null;
    let currentIndex = 0;
    let deckCards = [];
  let editingCardIndex = null;

    // Render deck selection grid (Anki-style)
    function renderDeckGrid() {
      const grid = document.getElementById('deckGrid');
      if(!grid) return;
      
      grid.innerHTML = '';
      
      if(store.decks.length === 0) {
        grid.innerHTML = '<div style="grid-column:1/-1;text-align:center;padding:40px;color:var(--muted)">ãƒ‡ãƒƒã‚­ãŒã‚ã‚Šã¾ã›ã‚“ã€‚æ–°ã—ã„ãƒ‡ãƒƒã‚­ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚</div>';
        return;
      }
      
      store.decks.forEach(d => {
        const card = document.createElement('div');
        card.style.cssText = 'padding:20px;background:rgba(40,40,60,0.6);border:1px solid rgba(255,102,170,0.2);border-radius:12px;cursor:pointer;transition:all 0.3s ease';
        card.innerHTML = `
          <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:12px">
            <h3 style="margin:0;color:#fff;font-size:1.1rem">${d.name}</h3>
            <button class="delete-deck-btn" data-id="${d.id}" style="background:none;border:none;color:var(--muted);cursor:pointer;padding:4px;font-size:1.2rem" title="å‰Šé™¤">Ã—</button>
          </div>
          <div style="color:var(--muted);font-size:0.9rem">
            <div>ã‚«ãƒ¼ãƒ‰: ${(d.cards || []).length}æš</div>
            <div style="margin-top:4px">ä½œæˆæ—¥: ${new Date(d.createdAt || Date.now()).toLocaleDateString('ja-JP')}</div>
          </div>
        `;
        
        card.addEventListener('click', (e) => {
          if(e.target.classList.contains('delete-deck-btn')) {
            e.stopPropagation();
            const id = e.target.dataset.id;
            if(confirm('ã“ã®ãƒ‡ãƒƒã‚­ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
              store.decks = store.decks.filter(deck => deck.id !== id);
              save(store);
              renderDeckGrid();
            }
            return;
          }
          openDeckEditor(d.id);
        });
        
        card.addEventListener('mouseenter', () => {
          card.style.background = 'rgba(50,50,75,0.8)';
          card.style.borderColor = 'rgba(255,102,170,0.4)';
          card.style.transform = 'translateY(-2px)';
        });
        
        card.addEventListener('mouseleave', () => {
          card.style.background = 'rgba(40,40,60,0.6)';
          card.style.borderColor = 'rgba(255,102,170,0.2)';
          card.style.transform = 'translateY(0)';
        });
        
        grid.appendChild(card);
      });
    }
    
    function openDeckEditor(deckId) {
      const d = store.decks.find(x => x.id === deckId);
      if(!d) return;
      
      currentDeckId = d.id;
      deckCards = d.cards || [];
      
      document.getElementById('deckSelection').style.display = 'none';
      document.getElementById('cardEditor').style.display = 'block';
      document.getElementById('currentDeckName').textContent = d.name;
      document.getElementById('cardCount').textContent = deckCards.length;
      
      renderCardsList();
      
      // Re-attach event listeners for buttons in card editor
      const startLearnBtn = document.getElementById('startLearnBtn');
      const startTestBtn = document.getElementById('startTestBtn');
      const backToDeckBtn = document.getElementById('backToDeckBtn');
      const deleteDeckBtn = document.getElementById('deleteDeckBtn');
      
      if(startLearnBtn) {
        startLearnBtn.onclick = () => {
          if(!deckCards.length) {
            alert('ã‚«ãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“ã€‚å…ˆã«ã‚«ãƒ¼ãƒ‰ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚');
            return;
          }
          currentMode = 'learn';
          loadChecks();
          showSettingsScreen();
        };
      }
      
      if(startTestBtn) {
        startTestBtn.onclick = () => {
          if(!deckCards.length) {
            alert('ã‚«ãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“ã€‚å…ˆã«ã‚«ãƒ¼ãƒ‰ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚');
            return;
          }
          currentMode = 'test';
          updateMode();
        };
      }
      
      if(backToDeckBtn) {
        backToDeckBtn.onclick = () => {
          showDeckSelection();
        };
      }
      
      if(deleteDeckBtn) {
        deleteDeckBtn.onclick = () => {
          if(!currentDeckId) return;
          if(!confirm('ã“ã®ãƒ‡ãƒƒã‚­ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“')) return;
          store.decks = store.decks.filter(d=>d.id!==currentDeckId); 
          save(store); 
          showDeckSelection();
        };
      }
    }
    
    function showDeckSelection() {
      document.getElementById('deckSelection').style.display = 'block';
      document.getElementById('cardEditor').style.display = 'none';
      document.getElementById('studySettings').style.display = 'none';
      studyArea.style.display = 'none';
      testArea.style.display = 'none';
      
      renderDeckGrid();
    }

    function loadDeck(){ const d = store.decks.find(x=>x.id===currentDeckId); if(!d){ deckCards=[]; cardsList.innerHTML=''; currentDeckId=null; return;} deckCards=d.cards||[]; renderCardsList(); }

    function showEditUI(deckId){
      isEditing = true;
      topControls.style.display = 'block'; cardRegister.style.display = 'block'; document.getElementById('deckArea').style.display = 'block';
      studyArea.style.display = 'none'; testArea.style.display = 'none';
      if(openMemHeaderBtn) openMemHeaderBtn.style.display = 'none';
      if(deckId){ try{ deckSelect.value = deckId; }catch(e){} }
      loadDeck();
      updateOpenResultsBtn();
    }

    function renderCardsList(){ 
      cardsList.innerHTML=''; 
      
      // Update card count
      const countEl = document.getElementById('cardCount');
      if(countEl) countEl.textContent = deckCards.length;
      
      if(deckCards.length === 0) {
        cardsList.innerHTML = '<div style="text-align:center;padding:20px;color:var(--muted)">ã‚«ãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“</div>';
        return;
      }
      
      deckCards.forEach((c,i)=>{ 
        const el=document.createElement('div'); 
        el.style.cssText = 'display:flex;justify-content:space-between;align-items:center;gap:8px;padding:12px;background:rgba(20,20,30,0.6);border-radius:8px;border:1px solid rgba(255,102,170,0.1)';
        
        const left=document.createElement('div'); 
        left.style.cssText = 'flex:1;color:#fff';
        left.textContent=(i+1)+'. '+(c.front.slice(0,80)); 
        
        const btns=document.createElement('div'); 
        btns.style.display='flex'; 
        btns.style.gap='6px'; 
        
        const edit=document.createElement('button'); 
        edit.className='btn secondary'; 
        edit.textContent='ç·¨é›†'; 
        edit.style.padding = '6px 12px';
        edit.addEventListener('click', ()=>{ 
          editingCardIndex = i;
          cardFront.value = c.front;
          cardBack.value = c.back;
          saveCardBtn.textContent = 'æ›´æ–°';
          cardFront.focus();
        });
        
        const del=document.createElement('button'); 
        del.className='btn danger'; 
        del.textContent='å‰Šé™¤'; 
        del.style.padding = '6px 12px';
        del.addEventListener('click', ()=>{ 
          if(!confirm('ã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ'))return; 
          deckCards.splice(i,1); 
          persistDeck(); 
          renderCardsList(); 
        }); 
        
        btns.appendChild(edit); 
        btns.appendChild(del); 
        el.appendChild(left); 
        el.appendChild(btns); 
        cardsList.appendChild(el); 
      }); 
    }

    function persistDeck(){ const idx = store.decks.findIndex(d=>d.id===currentDeckId); if(idx===-1) return; store.decks[idx].cards = deckCards; save(store); }

    createDeckBtn.addEventListener('click', ()=>{
      const name = newDeckName.value.trim(); 
      if(!name) return alert('ãƒ‡ãƒƒã‚­åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
      const d = { id: uid(), name, cards: [], createdAt: Date.now() }; 
      store.decks.push(d); 
      save(store); 
      newDeckName.value=''; 
      renderDeckGrid();
    });
    


    insertBlankBtn.addEventListener('click', ()=>{
      const el = cardFront; const start = el.selectionStart||0; const end = el.selectionEnd||0; const v = el.value; el.value = v.slice(0,start) + '()' + v.slice(end); el.selectionStart = el.selectionEnd = start + 1; el.focus();
    });

    saveCardBtn.addEventListener('click', ()=>{
      if(!currentDeckId) return alert('å…ˆã«ãƒ‡ãƒƒã‚­ã‚’é¸æŠã¾ãŸã¯ä½œæˆã—ã¦ãã ã•ã„');
      const f = cardFront.value.trim(); const b = cardBack.value.trim(); if(!f) return alert('è¡¨ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
      if(editingCardIndex !== null && typeof editingCardIndex === 'number'){
        // update existing card
        const existing = deckCards[editingCardIndex] || {};
        deckCards[editingCardIndex] = { id: existing.id || uid(), front: f, back: b };
        editingCardIndex = null;
        saveCardBtn.textContent = 'ã‚«ãƒ¼ãƒ‰ã‚’ä¿å­˜';
      } else {
        const card = { id: uid(), front: f, back: b };
        deckCards.push(card);
      }
      persistDeck(); renderCardsList(); cardFront.value=''; cardBack.value='';
      // restore header edit button visibility
      if(toggleEditBtn) toggleEditBtn.style.display = '';
      if(openMemHeaderBtn) openMemHeaderBtn.style.display = '';
      updateOpenResultsBtn();
    });
    clearCardBtn.addEventListener('click', ()=>{ cardFront.value=''; cardBack.value=''; editingCardIndex = null; saveCardBtn.textContent = 'ã‚«ãƒ¼ãƒ‰ã‚’ä¿å­˜'; if(toggleEditBtn) toggleEditBtn.style.display = ''; if(openMemHeaderBtn) openMemHeaderBtn.style.display = ''; updateOpenResultsBtn(); });

  // Anki-like features
  let cardChecks = {}; // {cardId: boolean}
  let autoFlipTimer = null;
  let isCardFlipped = false;
  let studySettings = {
    easyFlip: false,
    hideChecked: false,
    reverseCards: false,
    shuffleCards: false,
    infiniteLoop: false,
    autoFlip: false,
    autoFlipTime: 3,
    autoFlipTime2: 3
  };
  
  // Load checks from localStorage
  function loadChecks() {
    try {
      const saved = localStorage.getItem(`kiroku_checks_${currentDeckId}`);
      cardChecks = saved ? JSON.parse(saved) : {};
    } catch(e) {
      cardChecks = {};
    }
  }
  
  function saveChecks() {
    try {
      localStorage.setItem(`kiroku_checks_${currentDeckId}`, JSON.stringify(cardChecks));
    } catch(e) {}
  }
  
  // Load settings from localStorage
  function loadSettings() {
    try {
      const saved = localStorage.getItem('kiroku_study_settings');
      if(saved) {
        studySettings = {...studySettings, ...JSON.parse(saved)};
      }
    } catch(e) {}
  }
  
  function saveSettings() {
    try {
      localStorage.setItem('kiroku_study_settings', JSON.stringify(studySettings));
    } catch(e) {}
  }
  
  // Apply settings to UI
  function applySettingsToUI() {
    document.getElementById('easyFlip').checked = studySettings.easyFlip;
    document.getElementById('hideChecked').checked = studySettings.hideChecked;
    document.getElementById('reverseCards').checked = studySettings.reverseCards;
    document.getElementById('shuffleCards').checked = studySettings.shuffleCards;
    document.getElementById('infiniteLoop').checked = studySettings.infiniteLoop;
    document.getElementById('autoFlip').checked = studySettings.autoFlip;
    document.getElementById('autoFlipTime').value = studySettings.autoFlipTime;
    document.getElementById('autoFlipTime2').value = studySettings.autoFlipTime2;
    
    // Show/hide auto flip settings
    document.getElementById('autoFlipSettings').style.display = studySettings.autoFlip ? 'block' : 'none';
  }
  
  // Read settings from UI
  function readSettingsFromUI() {
    studySettings.easyFlip = document.getElementById('easyFlip').checked;
    studySettings.hideChecked = document.getElementById('hideChecked').checked;
    studySettings.reverseCards = document.getElementById('reverseCards').checked;
    studySettings.shuffleCards = document.getElementById('shuffleCards').checked;
    studySettings.infiniteLoop = document.getElementById('infiniteLoop').checked;
    studySettings.autoFlip = document.getElementById('autoFlip').checked;
    studySettings.autoFlipTime = parseFloat(document.getElementById('autoFlipTime').value);
    studySettings.autoFlipTime2 = parseFloat(document.getElementById('autoFlipTime2').value);
  }
  
  // Show settings screen
  function showSettingsScreen() {
    loadSettings();
    loadChecks();
    applySettingsToUI();
    
    topControls.style.display = 'none';
    cardRegister.style.display = 'none';
    document.getElementById('deckArea').style.display = 'none';
    document.getElementById('studySettings').style.display = 'block';
    studyArea.style.display = 'none';
    testArea.style.display = 'none';
  }
  
  // Start study (Anki-style)
  document.getElementById('startStudyBtn')?.addEventListener('click', () => {
    readSettingsFromUI();
    saveSettings();
    
    // Apply shuffle if enabled
    if(studySettings.shuffleCards) {
      for(let i = deckCards.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [deckCards[i], deckCards[j]] = [deckCards[j], deckCards[i]];
      }
    }
    
    // Show study screen
    document.getElementById('studySettings').style.display = 'none';
    studyArea.style.display = 'block';
    
    // Start from first card
    currentIndex = 0;
    showStudy(0);
  });
  
  // Pause study (back to settings)
  document.getElementById('pauseStudyBtn')?.addEventListener('click', () => {
    if(autoFlipTimer) {
      clearTimeout(autoFlipTimer);
      autoFlipTimer = null;
    }
    studyArea.style.display = 'none';
    showSettingsScreen();
  });
  
  // Stop study (back to edit)
  document.getElementById('stopStudyBtn')?.addEventListener('click', () => {
    if(autoFlipTimer) {
      clearTimeout(autoFlipTimer);
      autoFlipTimer = null;
    }
    studyArea.style.display = 'none';
    document.getElementById('studySettings').style.display = 'none';
    topControls.style.display = 'block';
    cardRegister.style.display = 'block';
    document.getElementById('deckArea').style.display = 'block';
  });
  
  // Auto-flip settings toggle
  document.getElementById('autoFlip')?.addEventListener('change', (e) => {
    document.getElementById('autoFlipSettings').style.display = e.target.checked ? 'block' : 'none';
  });
  
  // Reset checks button
  document.getElementById('resetChecks')?.addEventListener('click', () => {
    if(confirm('ã™ã¹ã¦ã®ãƒã‚§ãƒƒã‚¯ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿ')) {
      cardChecks = {};
      saveChecks();
      alert('ãƒã‚§ãƒƒã‚¯ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ');
    }
  });
  
  // study mode (Anki-style with animations and features)
  function showStudy(i){ 
    if(!deckCards.length) return; 
    
    // Stop auto-flip timer
    if(autoFlipTimer) {
      clearTimeout(autoFlipTimer);
      autoFlipTimer = null;
    }
    
    // Filter cards if hideChecked is enabled
    let visibleCards = deckCards;
    if(studySettings.hideChecked) {
      visibleCards = deckCards.filter(c => !cardChecks[c.id]);
      if(visibleCards.length === 0) {
        alert('ã™ã¹ã¦ã®ã‚«ãƒ¼ãƒ‰ã«ãƒã‚§ãƒƒã‚¯ãŒä»˜ã„ã¦ã„ã¾ã™ï¼');
        document.getElementById('stopStudyBtn').click();
        return;
      }
    }
    
    currentIndex = (i + visibleCards.length) % visibleCards.length; 
    const c = visibleCards[currentIndex]; 
    
    // Card flip animation
    const card = document.getElementById('studyCard');
    card.style.transform = 'rotateY(90deg)';
    
    setTimeout(() => {
      // Apply reverse if enabled
      if(studySettings.reverseCards) {
        studyFront.textContent = c.back; 
        studyBack.textContent = c.front;
      } else {
        studyFront.textContent = c.front; 
        studyBack.textContent = c.back;
      }
      studyBack.style.display='none';
      isCardFlipped = false;
      
      // Update check mark
      const checkMark = document.getElementById('checkMark');
      const checkSvg = checkMark?.querySelector('svg');
      if(checkMark && checkSvg) {
        checkMark.querySelector('input').checked = cardChecks[c.id] || false;
        checkSvg.style.fill = cardChecks[c.id] ? 'rgba(255,102,170,1)' : 'rgba(255,102,170,0.3)';
      }
      
      card.style.transform = 'rotateY(0deg)';
      
      // Update progress
      const actualIndex = deckCards.findIndex(card => card.id === c.id);
      progressEl.textContent = `${actualIndex + 1}/${deckCards.length}`;
      
      // Update progress bar
      const progressBarFill = document.getElementById('progressBarFill');
      if(progressBarFill) {
        const checkedCount = Object.values(cardChecks).filter(v => v).length;
        const percentage = (checkedCount / deckCards.length) * 100;
        progressBarFill.style.width = `${percentage}%`;
      }
      
      // Auto-flip if enabled
      if(studySettings.autoFlip) {
        const time = studySettings.autoFlipTime * 1000;
        autoFlipTimer = setTimeout(() => {
          if(!isCardFlipped) {
            revealCard();
          }
        }, time);
      }
    }, 150);
  }
  
  function revealCard() {
    studyBack.style.display='block';
    isCardFlipped = true;
    
    // Award score for studying
    if (window.ScoreSystem) {
      window.ScoreSystem.addScore(5, 'æš—è¨˜å­¦ç¿’');
    }
    
    // Auto-advance if auto-flip is enabled
    if(studySettings.autoFlip) {
      const time = studySettings.autoFlipTime2 * 1000;
      autoFlipTimer = setTimeout(() => {
        goToNextCard();
      }, time);
    }
  }
  
  // Click card to flip (only if easyFlip is enabled)
  document.getElementById('studyCard')?.addEventListener('click', (e) => {
    // Don't flip when clicking check mark
    if(e.target.closest('label')) return;
    
    if(studySettings.easyFlip) {
      if(!isCardFlipped) {
        revealCard();
      } else {
        goToNextCard();
      }
    }
  });
  
  // Check mark toggle (Anki-style)
  document.getElementById('checkMark')?.addEventListener('change', (e) => {
    let visibleCards = studySettings.hideChecked ? deckCards.filter(c => !cardChecks[c.id]) : deckCards;
    const c = visibleCards[currentIndex];
    if(c) {
      cardChecks[c.id] = e.target.checked;
      saveChecks();
      
      const checkSvg = e.target.parentElement.querySelector('svg');
      if(checkSvg) {
        checkSvg.style.fill = cardChecks[c.id] ? 'rgba(255,102,170,1)' : 'rgba(255,102,170,0.3)';
      }
      
      // Update progress bar
      const progressBarFill = document.getElementById('progressBarFill');
      if(progressBarFill) {
        const checkedCount = Object.values(cardChecks).filter(v => v).length;
        const percentage = (checkedCount / deckCards.length) * 100;
        progressBarFill.style.width = `${percentage}%`;
      }
    }
  });
  
  // Navigation functions
  function goToNextCard() {
    let visibleCards = studySettings.hideChecked ? deckCards.filter(c => !cardChecks[c.id]) : deckCards;
    
    if(currentIndex + 1 >= visibleCards.length) {
      if(studySettings.infiniteLoop) {
        // Loop back to start
        showStudy(0);
      } else {
        // End of deck
        if(autoFlipTimer) clearTimeout(autoFlipTimer);
        if(confirm('å­¦ç¿’å®Œäº†ï¼ã‚‚ã†ä¸€åº¦æš—è¨˜ã—ã¾ã™ã‹ï¼Ÿ')) {
          showStudy(0);
        } else {
          document.getElementById('stopStudyBtn').click();
        }
      }
    } else {
      showStudy(currentIndex + 1);
    }
  }
  
  function goToPrevCard() {
    if(currentIndex > 0) {
      showStudy(currentIndex - 1);
    } else if(studySettings.infiniteLoop) {
      let visibleCards = studySettings.hideChecked ? deckCards.filter(c => !cardChecks[c.id]) : deckCards;
      showStudy(visibleCards.length - 1);
    }
  }
  
  // Button handlers
  document.getElementById('revealCardBtn')?.addEventListener('click', () => {
    if(!isCardFlipped) {
      revealCard();
    } else {
      goToNextCard();
    }
  });
  
  document.getElementById('nextCardBtn')?.addEventListener('click', () => {
    goToNextCard();
  });
  
  document.getElementById('prevCardBtn')?.addEventListener('click', () => {
    goToPrevCard();
  });
  
  // Keyboard shortcuts (Anki-style)
  document.addEventListener('keydown', (e) => {
    if(studyArea.style.display === 'none') return;
    
    if(e.key === 'Enter') {
      e.preventDefault();
      if(!isCardFlipped) {
        revealCard();
      } else {
        goToNextCard();
      }
    } else if(e.key === 'ArrowLeft') {
      e.preventDefault();
      goToPrevCard();
    } else if(e.key === 'ArrowRight') {
      e.preventDefault();
      goToNextCard();
    } else if(e.key === ' ') {
      e.preventDefault();
      const checkInput = document.getElementById('checkMark');
      if(checkInput) {
        checkInput.checked = !checkInput.checked;
        checkInput.dispatchEvent(new Event('change'));
      }
    }
  });

    // test mode (ç©´åŸ‹ã‚)
    function buildTestForCard(c){ // returns {htmlFront, answers[], blanks}
      // find occurrences of () in front and create inputs
      const parts = c.front.split('()');
      const blanks = Math.max(0, parts.length - 1);
      // parse answers: prefer explicit '||', otherwise try common separators (æ”¹è¡Œ, ã‚«ãƒ³ãƒ, èª­ç‚¹, ã‚»ãƒŸã‚³ãƒ­ãƒ³, ãƒ‘ã‚¤ãƒ—), then whitespace
      function parseAnswers(back, expected){
        if(!back) return [];
        if(back.indexOf('||') !== -1) return back.split('||').map(s=>s.trim()).filter(x=>x!=='');
        let parts = back.split(/\s*[\nã€,ï¼Œ;ï¼›|]\s*/).map(s=>s.trim()).filter(x=>x!=='');
        if(parts.length === 1 && expected > 1){ // try whitespace split if user just typed space-separated
          parts = back.split(/\s+/).map(s=>s.trim()).filter(x=>x!=='');
        }
        return parts;
      }
      const rawAnswers = parseAnswers(c.back||'', blanks);
      // pad or trim to match blanks count (use blanks as source of truth)
      const answers = [];
      for(let i=0;i<blanks;i++) answers.push(rawAnswers[i] || '');
      let html = '';
      for(let i=0;i<parts.length;i++){
        html += '<span>'+escapeHtml(parts[i])+'</span>';
        if(i<blanks) html += `<span class="mem-blank" style="display:inline-block;min-width:80px;padding:6px;border-bottom:2px dashed var(--muted);margin:4px;height:1.2em;vertical-align:middle;text-align:center;color:var(--muted)">(${i+1})</span>`;
      }
      return { htmlFront: html, answers, blanks };
    }
    function escapeHtml(s){ return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

    function showTest(i){ if(!deckCards.length) return; currentIndex = (i+deckCards.length)%deckCards.length; const c = deckCards[currentIndex]; const built = buildTestForCard(c);
      testFront.innerHTML = ''; testFront.appendChild(document.createElement('div')).innerHTML = built.htmlFront;
      testInputs.innerHTML = '';
      // create inputs equal to blanks/answers
      const inputsWrapper = document.createElement('div'); inputsWrapper.style.display='flex'; inputsWrapper.style.gap='8px'; inputsWrapper.style.alignItems='center'; inputsWrapper.style.marginTop='12px'; inputsWrapper.style.width='100%';
      const answerCount = built.answers.length || 0;
      let firstInput = null;
      for(let k=0;k<answerCount;k++){
        const inp = document.createElement('input'); inp.className = 'mem-input'; inp.dataset.idx = k; inp.style.minWidth = '160px'; inp.style.padding='10px'; inp.style.border='2px solid #3b82f6'; inp.style.borderRadius='8px'; inp.style.fontSize='1rem'; inp.placeholder = `ç©ºæ¬„ ${k+1}`;
        inputsWrapper.appendChild(inp);
        if(k===0) firstInput = inp;
      }
  // action button (starts as åˆ¤å®š, becomes æ¬¡ã¸ afteråˆ¤å®š)
  const action = document.createElement('button'); action.id = 'mem-action-btn'; action.type='button'; action.className = 'btn'; action.textContent = 'åˆ¤å®š'; action.style.flex = '0 0 auto';
  inputsWrapper.appendChild(action);
      testInputs.appendChild(inputsWrapper);
      testResult.textContent=''; testSummary.style.display='none';
      // focus first input
      if(firstInput) setTimeout(()=>{ firstInput.focus(); },50);
  // attach handler
  action.onclick = ()=>{ evaluateCurrentAnswer(); };
  // allow Enter key on inputs to submit
  testInputs.querySelectorAll('.mem-input').forEach(inp=> inp.addEventListener('keydown', (e)=>{ if(e.key === 'Enter'){ e.preventDefault(); evaluateCurrentAnswer(); } }));
      // store answers and card metadata for evaluation and results page
      testFront.dataset.answers = JSON.stringify(built.answers);
      testFront.dataset.cardid = c.id || '';
      testFront.dataset.front = c.front || '';
      testFront.dataset.back = c.back || '';
      testFront.dataset.blanks = built.blanks || 0;
    }

    // test mode flow with session tracking, big emoji feedback and final summary
    function showFeedback(isCorrect){ feedbackEmoji.textContent = isCorrect ? 'â­•ï¸' : 'âŒ'; feedbackOverlay.style.display = 'flex'; setTimeout(()=>{ feedbackOverlay.style.display = 'none'; }, 800); }

  function startTestSession(){ testSession = { total: deckCards.length, correct: 0, seen: 0, entries: [] }; }

    // evaluate answer typed into the single input and then advance
    function evaluateCurrentAnswer(){ if(!deckCards.length) return; const c = deckCards[currentIndex]; const inputs = Array.from(document.querySelectorAll('#testInputs .mem-input'));
      // read answers computed when building the test (ensures we use blanks-based splitting/padding)
      let answers = [];
      try{ answers = JSON.parse(testFront.dataset.answers || '[]'); }catch(e){ answers = []; }
      const entered = inputs.map(i=>i.value.trim());
      if(entered.length !== answers.length){ testResult.style.color='orange'; testResult.textContent = `ç©ºæ¬„æ•°ã¨è§£ç­”æ•°ãŒä¸€è‡´ã—ã¾ã›ã‚“ï¼ˆå…¥åŠ›: ${entered.length} æœŸå¾…: ${answers.length}ï¼‰ã€‚`; return; }
      let correct = 0; for(let i=0;i<answers.length;i++){ if(entered[i] === answers[i]) correct++; }
      const isCorrect = (correct === answers.length);
      // update session
      testSession.seen++; if(isCorrect) testSession.correct++;
      
      // Award score for test
      if (window.ScoreSystem) {
        if (isCorrect) {
          window.ScoreSystem.addScore(10, 'æš—è¨˜ãƒ†ã‚¹ãƒˆæ­£è§£ï¼');
        }
      }
      
      // record per-card entry for results
      try{
        const entry = { cardId: testFront.dataset.cardid || c.id, front: testFront.dataset.front || c.front, back: testFront.dataset.back || c.back, expected: answers, entered: entered, correct: isCorrect };
        if(!testSession.entries) testSession.entries = [];
        testSession.entries.push(entry);
      }catch(e){ console.warn('record entry failed', e); }
      // show feedback
      showFeedback(isCorrect);
      testResult.style.color = isCorrect ? 'green' : 'red'; testResult.textContent = `æ­£ç­” ${correct}/${answers.length}`;
      // disable inputs
      inputs.forEach(inp=> inp.disabled = true);
      // reveal correct answers inline
      try{
        const blanksEls = testFront.querySelectorAll('.mem-blank');
        blanksEls.forEach((el, idx)=>{ el.textContent = answers[idx] || ''; el.style.color = 'var(--muted)'; el.style.borderBottom = 'none'; });
      }catch(e){ /* ignore */ }
      // change action button to 'æ¬¡ã¸' so user advances manually; if last, it will show results
      try{
        const action = document.getElementById('mem-action-btn'); if(action){ action.textContent = (testSession.seen >= testSession.total) ? 'çµæœã‚’è¦‹ã‚‹' : 'æ¬¡ã¸'; action.onclick = ()=>{ if(testSession.seen >= testSession.total){ showResults(); } else { showTest(currentIndex+1); } }; }
      }catch(e){ }
    }
    document.getElementById('testPrevBtn').addEventListener('click', ()=>{ showTest(currentIndex-1); });

  // mode toggle: when switching to learn/test, hide creation UI and deck list so study/test use full screen
  function updateMode(){ if(isEditing) return; const hasCards = deckCards.length>0; const mode = currentMode || 'learn';
    // ensure header memorization button visible when not editing
    if(openMemHeaderBtn) openMemHeaderBtn.style.display = '';
    // hide edit UI
      topControls.style.display = 'none'; cardRegister.style.display='none'; document.getElementById('deckArea').style.display='none';
      if(mode==='learn'){
        studyArea.style.display = hasCards ? 'block' : 'none';
        testArea.style.display='none';
        // ensure test prev button hidden in learn mode area
        const testPrev = document.getElementById('testPrevBtn'); if(testPrev) testPrev.style.display = 'inline-block';
        if(hasCards) { showStudy(0); }
      } else {
        testArea.style.display = hasCards ? 'block' : 'none';
        studyArea.style.display='none';
        // hide the test "å‰ã¸" button during test mode if desired
        const testPrev = document.getElementById('testPrevBtn'); if(testPrev) testPrev.style.display = 'none';
        if(hasCards) { startTestSession(); showTest(0); }
      }
    }


  // init
  showDeckSelection();
  // handle importDeck param (shared links)
  const importParam = urlParams.get('importDeck');
  if(importParam){
    try{
      function decodeSharedDeck(s){
        try{ const b64 = decodeURIComponent(s); const json = decodeURIComponent(escape(atob(b64))); return JSON.parse(json); }catch(e){ try{ const b64 = decodeURIComponent(s); return JSON.parse(atob(b64)); }catch(err){ return null; } }
      }
      const imported = decodeSharedDeck(importParam);
      if(imported){ imported.id = uid(); imported.name = (imported.name||'å…±æœ‰ãƒ‡ãƒƒã‚­') + ' (å…±æœ‰)'; store.decks.push(imported); save(store); renderDeckSelect(); deckSelect.value = imported.id; loadDeck(); notify('å…±æœ‰ãƒ‡ãƒƒã‚­ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ'); showEditUI(imported.id); }
    }catch(e){ console.warn('import failed', e); }
  }
  // prefer sessionStorage flag (set by showResults) as it's more reliable than query params
  const pendingEdit = sessionStorage.getItem('kiroku_lot_open_edit');
  if(pendingEdit){ try{ sessionStorage.removeItem('kiroku_lot_open_edit'); showEditUI(pendingEdit); }catch(e){ showEditUI(pendingEdit); } }
  else if(showEditOnLoad){ const deckIdFromUrl = urlParams.get('deck'); showEditUI(deckIdFromUrl); }
  else { updateMode(); }

  // wire the header 'è¨˜éŒ²ãƒ¢ãƒ¼ãƒ‰' button to open results for current deck
  const openResultsBtn = document.getElementById('openResultsBtn');
  function updateOpenResultsBtn(){
    if(!openResultsBtn) return;
    // ensure anchor has href so navigation works without JS interference
    try{ openResultsBtn.setAttribute('href', 'index.html'); openResultsBtn.title = 'ç‚¹æ•°è¨˜éŒ²ãƒšãƒ¼ã‚¸ã«æˆ»ã‚‹'; openResultsBtn.style.opacity='1'; openResultsBtn.style.pointerEvents='auto'; }catch(e){}
  }
  // update when deck changes
  deckSelect.addEventListener('change', ()=>{ loadDeck(); updateOpenResultsBtn(); });
  updateOpenResultsBtn();
  if(openResultsBtn){ openResultsBtn.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation();
    // clear any pending edit flag
    try{ sessionStorage.removeItem('kiroku_lot_open_edit'); }catch(e){}
    // navigate to the score recording (ä¸€è¦§) page
    window.location.href = 'index.html';
  }); }
  // share current deck to clipboard as a link
  if(shareDeckBtn){ shareDeckBtn.addEventListener('click', async (e)=>{ e.preventDefault(); e.stopPropagation(); if(!currentDeckId){ alert('å…ˆã«ãƒ‡ãƒƒã‚­ã‚’é¸æŠã—ã¦ãã ã•ã„'); return; } const deck = store.decks.find(d=>d.id===currentDeckId); if(!deck){ alert('é¸æŠä¸­ã®ãƒ‡ãƒƒã‚­ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'); return; } try{ const s = JSON.stringify(deck); const b64 = btoa(unescape(encodeURIComponent(s))); const enc = encodeURIComponent(b64); const link = location.origin + location.pathname + '?importDeck=' + enc; if(navigator.clipboard && navigator.clipboard.writeText){ await navigator.clipboard.writeText(link); notify('å…±æœ‰ãƒªãƒ³ã‚¯ã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ'); } else { const ta = document.createElement('textarea'); ta.value = link; document.body.appendChild(ta); ta.select(); document.execCommand('copy'); ta.remove(); notify('å…±æœ‰ãƒªãƒ³ã‚¯ã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰'); } }catch(err){ console.warn('share failed', err); alert('å…±æœ‰ãƒªãƒ³ã‚¯ã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ'); } }); }

    // Results display
    function drawResultChart(correct, incorrect){ try{ const c = resultChart.getContext('2d'); const total = correct + incorrect; const angle = (correct/total) * Math.PI * 2; c.clearRect(0,0,resultChart.width,resultChart.height); const cx = resultChart.width/2; const cy = resultChart.height/2; const r = Math.min(cx,cy)-8; // background
        // correct (red)
        c.beginPath(); c.moveTo(cx,cy); c.fillStyle = '#ef4444'; c.arc(cx,cy,r,-Math.PI/2, -Math.PI/2 + angle); c.closePath(); c.fill();
        // incorrect (blue)
        c.beginPath(); c.moveTo(cx,cy); c.fillStyle = '#3b82f6'; c.arc(cx,cy,r,-Math.PI/2 + angle, -Math.PI/2 + Math.PI*2); c.closePath(); c.fill();
      }catch(e){ console.warn('draw chart failed', e); } }

    const RESULTS_HISTORY_KEY = 'kiroku_lot_cards_results_history_v1';
    function loadResultsHistory(){ try{ const r = localStorage.getItem(RESULTS_HISTORY_KEY); return r?JSON.parse(r):{}; }catch(e){return{};} }
    function saveResultsHistory(obj){ try{ localStorage.setItem(RESULTS_HISTORY_KEY, JSON.stringify(obj)); }catch(e){} }

    function showResults(){ if(!testSession) return; const total = testSession.total; const correct = testSession.correct; const incorrect = total - correct; const pct = total? (correct/total*100) : 0; const prev = resultsStore[currentDeckId]; // persist current result
      resultsStore[currentDeckId] = pct; saveResults(resultsStore);
      // append to history
      try{
        const hist = loadResultsHistory(); if(!hist[currentDeckId]) hist[currentDeckId]=[];
        hist[currentDeckId].push({ t: Date.now(), pct: pct });
        // keep recent 100
        if(hist[currentDeckId].length>100) hist[currentDeckId]=hist[currentDeckId].slice(-100);
        saveResultsHistory(hist);
      }catch(e){ console.warn('save history failed', e); }
      // save last result to sessionStorage for the results page
  try{ sessionStorage.setItem('kiroku_lot_last_result', JSON.stringify({ deckId: currentDeckId, pct: pct, prev: typeof prev === 'number' ? prev : null, correct, incorrect, entries: testSession.entries || [] })); }catch(e){}
      // set a flag so the results->memorization flow can open the editor reliably
      try{ sessionStorage.setItem('kiroku_lot_open_edit', currentDeckId); }catch(e){}
      // navigate to results page and request that results page show edit UI link
      window.location.href = 'memorization-results.html?deck=' + encodeURIComponent(currentDeckId) + '&edit=1';
    }

    // Clock update


    // Auth UI
    function updateAuthUI() {
      const accountId = localStorage.getItem('kl_account_id');
      const loginLink = document.getElementById('loginLink');
      const logoutBtn = document.getElementById('logoutBtn');
      const authUser = document.getElementById('authUser');
      
      if (accountId) {
        if (loginLink) loginLink.style.display = 'none';
        if (logoutBtn) logoutBtn.style.display = 'inline-block';
        if (authUser) {
          authUser.textContent = `acct:${accountId}`;
          authUser.style.display = 'inline-block';
        }
      } else {
        if (loginLink) loginLink.style.display = 'inline-block';
        if (logoutBtn) logoutBtn.style.display = 'none';
        if (authUser) authUser.style.display = 'none';
      }
    }

    updateAuthUI();
    const logoutBtn = document.getElementById('logoutBtn');
    if (logoutBtn) {
      logoutBtn.addEventListener('click', () => {
        localStorage.removeItem('kl_account_id');
        updateAuthUI();
        alert('ãƒ­ã‚°ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ');
        window.location.reload();
      });
    }
  })();
  </script>
</body>
</html>
